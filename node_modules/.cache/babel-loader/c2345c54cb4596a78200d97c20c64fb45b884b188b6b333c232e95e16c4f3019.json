{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, ref, toRef, computed, defineComponent, provide, watch, nextTick, watchEffect, inject } from 'vue';\nimport { createTreeMate, flatten, createIndexGetter } from 'treemate';\nimport { useMergedState } from 'vooks';\nimport { VVirtualList } from 'vueuc';\nimport { depx, getPadding, pxfy } from 'seemly';\nimport { treeSelectInjectionKey } from '../../tree-select/src/interface';\nimport { useConfig, useTheme, useThemeClass, useRtl } from '../../_mixins';\nimport { call, createDataKey, resolveSlot, warn, warnOnce } from '../../_utils';\nimport { NxScrollbar } from '../../_internal';\nimport { treeLight } from '../styles';\nimport { NEmpty } from '../../empty';\nimport NTreeNode from './TreeNode';\nimport { keysWithFilter, emptyImage, filterTree, isNodeDisabled, useMergedCheckStrategy } from './utils';\nimport { useKeyboard } from './keyboard';\nimport { treeInjectionKey } from './interface';\nimport MotionWrapper from './MotionWrapper';\nimport { defaultAllowDrop } from './dnd';\nimport style from './styles/index.cssr';\nexport function createTreeMateOptions(keyField, childrenField, disabledField, getChildren) {\n  const settledGetChildren = getChildren || (node => {\n    return node[childrenField];\n  });\n  return {\n    getIsGroup() {\n      return false;\n    },\n    getKey(node) {\n      return node[keyField];\n    },\n    getChildren: settledGetChildren,\n    getDisabled(node) {\n      return !!(node[disabledField] || node.checkboxDisabled);\n    }\n  };\n}\nexport const treeSharedProps = {\n  allowCheckingNotLoaded: Boolean,\n  filter: Function,\n  defaultExpandAll: Boolean,\n  expandedKeys: Array,\n  keyField: {\n    type: String,\n    default: 'key'\n  },\n  labelField: {\n    type: String,\n    default: 'label'\n  },\n  childrenField: {\n    type: String,\n    default: 'children'\n  },\n  disabledField: {\n    type: String,\n    default: 'disabled'\n  },\n  defaultExpandedKeys: {\n    type: Array,\n    default: () => []\n  },\n  indeterminateKeys: Array,\n  renderSwitcherIcon: Function,\n  onUpdateIndeterminateKeys: [Function, Array],\n  'onUpdate:indeterminateKeys': [Function, Array],\n  onUpdateExpandedKeys: [Function, Array],\n  'onUpdate:expandedKeys': [Function, Array]\n};\nexport const treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), {\n  accordion: Boolean,\n  showIrrelevantNodes: {\n    type: Boolean,\n    default: true\n  },\n  data: {\n    type: Array,\n    default: () => []\n  },\n  expandOnDragenter: {\n    type: Boolean,\n    default: true\n  },\n  expandOnClick: Boolean,\n  checkOnClick: {\n    type: [Boolean, Function],\n    default: false\n  },\n  cancelable: {\n    type: Boolean,\n    default: true\n  },\n  checkable: Boolean,\n  draggable: Boolean,\n  blockNode: Boolean,\n  blockLine: Boolean,\n  showLine: Boolean,\n  disabled: Boolean,\n  checkedKeys: Array,\n  defaultCheckedKeys: {\n    type: Array,\n    default: () => []\n  },\n  selectedKeys: Array,\n  defaultSelectedKeys: {\n    type: Array,\n    default: () => []\n  },\n  multiple: Boolean,\n  pattern: {\n    type: String,\n    default: ''\n  },\n  onLoad: Function,\n  cascade: Boolean,\n  selectable: {\n    type: Boolean,\n    default: true\n  },\n  scrollbarProps: Object,\n  indent: {\n    type: Number,\n    default: 24\n  },\n  allowDrop: {\n    type: Function,\n    default: defaultAllowDrop\n  },\n  animated: {\n    type: Boolean,\n    default: true\n  },\n  checkboxPlacement: {\n    type: String,\n    default: 'left'\n  },\n  virtualScroll: Boolean,\n  watchProps: Array,\n  renderLabel: Function,\n  renderPrefix: Function,\n  renderSuffix: Function,\n  nodeProps: Function,\n  keyboard: {\n    type: Boolean,\n    default: true\n  },\n  getChildren: Function,\n  onDragenter: [Function, Array],\n  onDragleave: [Function, Array],\n  onDragend: [Function, Array],\n  onDragstart: [Function, Array],\n  onDragover: [Function, Array],\n  onDrop: [Function, Array],\n  onUpdateCheckedKeys: [Function, Array],\n  'onUpdate:checkedKeys': [Function, Array],\n  onUpdateSelectedKeys: [Function, Array],\n  'onUpdate:selectedKeys': [Function, Array]\n}), treeSharedProps), {\n  // internal props for tree-select\n  internalTreeSelect: Boolean,\n  internalScrollable: Boolean,\n  internalScrollablePadding: String,\n  // use it to display\n  internalRenderEmpty: Function,\n  internalHighlightKeySet: Object,\n  internalUnifySelectCheck: Boolean,\n  internalCheckboxFocusable: {\n    type: Boolean,\n    default: true\n  },\n  internalFocusable: {\n    // Make tree-select take over keyboard operations\n    type: Boolean,\n    default: true\n  },\n  checkStrategy: {\n    type: String,\n    default: 'all'\n  },\n  /**\n   * @deprecated\n   */\n  leafOnly: Boolean\n});\nexport default defineComponent({\n  name: 'Tree',\n  props: treeProps,\n  setup(props) {\n    if (process.env.NODE_ENV !== 'production') {\n      watchEffect(() => {\n        if (props.leafOnly) {\n          warnOnce('tree', '`leaf-only` is deprecated, please use `check-strategy=\"child\"` instead');\n        }\n      });\n    }\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled,\n      mergedRtlRef\n    } = useConfig(props);\n    const rtlEnabledRef = useRtl('Tree', mergedRtlRef, mergedClsPrefixRef);\n    const themeRef = useTheme('Tree', '-tree', style, treeLight, props, mergedClsPrefixRef);\n    const selfElRef = ref(null);\n    const scrollbarInstRef = ref(null);\n    const virtualListInstRef = ref(null);\n    function getScrollContainer() {\n      var _a;\n      return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;\n    }\n    function getScrollContent() {\n      var _a;\n      return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;\n    }\n    const mergedFilterRef = computed(() => {\n      const {\n        filter\n      } = props;\n      if (filter) return filter;\n      const {\n        labelField\n      } = props;\n      return (pattern, node) => {\n        if (!pattern.length) return true;\n        const label = node[labelField];\n        if (typeof label === 'string') {\n          return label.toLowerCase().includes(pattern.toLowerCase());\n        }\n        return false;\n      };\n    });\n    const filteredTreeInfoRef = computed(() => {\n      const {\n        pattern\n      } = props;\n      if (!pattern) {\n        return {\n          filteredTree: props.data,\n          highlightKeySet: null,\n          expandedKeys: undefined\n        };\n      }\n      if (!pattern.length || !mergedFilterRef.value) {\n        return {\n          filteredTree: props.data,\n          highlightKeySet: null,\n          expandedKeys: undefined\n        };\n      }\n      return filterTree(props.data, mergedFilterRef.value, pattern, props.keyField, props.childrenField);\n    });\n    // We don't expect data source to change so we just determine it once\n    const displayTreeMateRef = computed(() => createTreeMate(props.showIrrelevantNodes ? props.data : filteredTreeInfoRef.value.filteredTree, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField, props.getChildren)));\n    const treeSelectInjection = inject(treeSelectInjectionKey, null);\n    const dataTreeMateRef = props.internalTreeSelect ? treeSelectInjection.dataTreeMate : displayTreeMateRef;\n    const {\n      watchProps\n    } = props;\n    const uncontrolledCheckedKeysRef = ref([]);\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultCheckedKeys')) {\n      watchEffect(() => {\n        uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n      });\n    } else {\n      uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n    }\n    const controlledCheckedKeysRef = toRef(props, 'checkedKeys');\n    const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);\n    const checkedStatusRef = computed(() => {\n      const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {\n        cascade: props.cascade,\n        allowNotLoaded: props.allowCheckingNotLoaded\n      });\n      return value;\n    });\n    const mergedCheckStrategyRef = useMergedCheckStrategy(props);\n    const displayedCheckedKeysRef = computed(() => {\n      return checkedStatusRef.value.checkedKeys;\n    });\n    const displayedIndeterminateKeysRef = computed(() => {\n      const {\n        indeterminateKeys\n      } = props;\n      if (indeterminateKeys !== undefined) return indeterminateKeys;\n      return checkedStatusRef.value.indeterminateKeys;\n    });\n    const uncontrolledSelectedKeysRef = ref([]);\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultSelectedKeys')) {\n      watchEffect(() => {\n        uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n      });\n    } else {\n      uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n    }\n    const controlledSelectedKeysRef = toRef(props, 'selectedKeys');\n    const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);\n    const uncontrolledExpandedKeysRef = ref([]);\n    const initUncontrolledExpandedKeys = keys => {\n      uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? dataTreeMateRef.value.getNonLeafKeys() : keys === undefined ? props.defaultExpandedKeys : keys;\n    };\n    if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {\n      // if watching defaultExpandedKeys, we use access props.defaultExpandedKeys inside initiator\n      watchEffect(() => {\n        initUncontrolledExpandedKeys(undefined);\n      });\n    } else {\n      // We by default watchEffect since if defaultExpandAll is true, we should remain tree expand if data changes\n      watchEffect(() => {\n        initUncontrolledExpandedKeys(props.defaultExpandedKeys);\n      });\n    }\n    const controlledExpandedKeysRef = toRef(props, 'expandedKeys');\n    const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);\n    const fNodesRef = computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));\n    const {\n      pendingNodeKeyRef,\n      handleKeydown\n    } = useKeyboard({\n      props,\n      mergedSelectedKeysRef,\n      fNodesRef,\n      mergedExpandedKeysRef,\n      handleSelect,\n      handleSwitcherClick\n    });\n    let expandTimerId = null;\n    let nodeKeyToBeExpanded = null;\n    const uncontrolledHighlightKeySetRef = ref(new Set());\n    const controlledHighlightKeySetRef = computed(() => {\n      return props.internalHighlightKeySet || filteredTreeInfoRef.value.highlightKeySet;\n    });\n    const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);\n    const loadingKeysRef = ref(new Set());\n    const expandedNonLoadingKeysRef = computed(() => {\n      return mergedExpandedKeysRef.value.filter(key => !loadingKeysRef.value.has(key));\n    });\n    let dragStartX = 0;\n    const draggingNodeRef = ref(null);\n    const droppingNodeRef = ref(null);\n    const droppingMouseNodeRef = ref(null);\n    const droppingPositionRef = ref(null);\n    const droppingOffsetLevelRef = ref(0);\n    const droppingNodeParentRef = computed(() => {\n      const {\n        value: droppingNode\n      } = droppingNodeRef;\n      if (!droppingNode) return null;\n      // May avoid overlap between line mark of first child & rect mark of parent\n      // if (droppingNode.isFirstChild && droppingPositionRef.value === 'before') {\n      //   return null\n      // }\n      return droppingNode.parent;\n    });\n    // shallow watch data\n    watch(toRef(props, 'data'), () => {\n      loadingKeysRef.value.clear();\n      pendingNodeKeyRef.value = null;\n      resetDndState();\n    }, {\n      deep: false\n    });\n    let expandAnimationDisabled = false;\n    const disableExpandAnimationForOneTick = () => {\n      expandAnimationDisabled = true;\n      void nextTick(() => {\n        expandAnimationDisabled = false;\n      });\n    };\n    let memoizedExpandedKeys;\n    watch(toRef(props, 'pattern'), (value, oldValue) => {\n      if (props.showIrrelevantNodes) {\n        memoizedExpandedKeys = undefined;\n        if (value) {\n          const {\n            expandedKeys: expandedKeysAfterChange,\n            highlightKeySet\n          } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);\n          uncontrolledHighlightKeySetRef.value = highlightKeySet;\n          disableExpandAnimationForOneTick();\n          doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), {\n            node: null,\n            action: 'filter'\n          });\n        } else {\n          uncontrolledHighlightKeySetRef.value = new Set();\n        }\n      } else {\n        if (!value.length) {\n          if (memoizedExpandedKeys !== undefined) {\n            disableExpandAnimationForOneTick();\n            doUpdateExpandedKeys(memoizedExpandedKeys, getOptionsByKeys(memoizedExpandedKeys), {\n              node: null,\n              action: 'filter'\n            });\n          }\n        } else {\n          if (!oldValue.length) {\n            memoizedExpandedKeys = mergedExpandedKeysRef.value;\n          }\n          const {\n            expandedKeys\n          } = filteredTreeInfoRef.value;\n          if (expandedKeys !== undefined) {\n            disableExpandAnimationForOneTick();\n            doUpdateExpandedKeys(expandedKeys, getOptionsByKeys(expandedKeys), {\n              node: null,\n              action: 'filter'\n            });\n          }\n        }\n      }\n    });\n    function triggerLoading(node) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const {\n          onLoad\n        } = props;\n        if (!onLoad) {\n          if (process.env.NODE_ENV !== 'production') {\n            warn('tree', 'There is unloaded node in data but props.onLoad is not specified.');\n          }\n          yield Promise.resolve();\n          return;\n        }\n        const {\n          value: loadingKeys\n        } = loadingKeysRef;\n        if (!loadingKeys.has(node.key)) {\n          loadingKeys.add(node.key);\n          try {\n            const loadResult = yield onLoad(node.rawNode);\n            if (loadResult === false) {\n              resetDragExpandState();\n            }\n          } catch (loadError) {\n            console.error(loadError);\n            resetDragExpandState();\n          }\n          loadingKeys.delete(node.key);\n        }\n      });\n    }\n    watchEffect(() => {\n      var _a;\n      const {\n        value: displayTreeMate\n      } = displayTreeMateRef;\n      if (!displayTreeMate) return;\n      const {\n        getNode\n      } = displayTreeMate;\n      (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach(key => {\n        const node = getNode(key);\n        if (node && !node.shallowLoaded) {\n          void triggerLoading(node);\n        }\n      });\n    });\n    // animation in progress\n    const aipRef = ref(false);\n    // animation flattened nodes\n    const afNodesRef = ref([]);\n    // Note: Since the virtual list depends on min height, if there's a node\n    // whose height starts from 0, the virtual list will have a wrong height\n    // during animation. This will seldom cause wired scrollbar status. It is\n    // fixable and need some changes in vueuc, I've no time so I just leave it\n    // here. Maybe the bug won't be fixed during the life time of the project.\n    watch(expandedNonLoadingKeysRef, (value, prevValue) => {\n      if (!props.animated || expandAnimationDisabled) {\n        void nextTick(syncScrollbar);\n        return;\n      }\n      const nodeHeight = depx(themeRef.value.self.nodeHeight);\n      const prevVSet = new Set(prevValue);\n      let addedKey = null;\n      let removedKey = null;\n      for (const expandedKey of value) {\n        if (!prevVSet.has(expandedKey)) {\n          if (addedKey !== null) return; // multi expand, not triggered by click\n          addedKey = expandedKey;\n        }\n      }\n      const currentVSet = new Set(value);\n      for (const expandedKey of prevValue) {\n        if (!currentVSet.has(expandedKey)) {\n          if (removedKey !== null) return; // multi collapse, not triggered by click\n          removedKey = expandedKey;\n        }\n      }\n      if (addedKey === null && removedKey === null) {\n        // 1. multi action, not triggered by click\n        // 2. no action, don't know what happened\n        return;\n      }\n      const {\n        virtualScroll\n      } = props;\n      const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;\n      const viewportItemCount = Math.ceil(viewportHeight / nodeHeight) + 1;\n      // play add animation\n      let baseExpandedKeys;\n      if (addedKey !== null) {\n        baseExpandedKeys = prevValue;\n      }\n      if (removedKey !== null) {\n        if (baseExpandedKeys === undefined) {\n          baseExpandedKeys = value;\n        } else {\n          baseExpandedKeys = baseExpandedKeys.filter(key => key !== removedKey);\n        }\n      }\n      aipRef.value = true;\n      afNodesRef.value = displayTreeMateRef.value.getFlattenedNodes(baseExpandedKeys);\n      if (addedKey !== null) {\n        const expandedNodeIndex = afNodesRef.value.findIndex(node => node.key === addedKey);\n        if (~expandedNodeIndex) {\n          const children =\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          afNodesRef.value[expandedNodeIndex].children;\n          // sometimes user will pass leaf keys in\n          if (children) {\n            const expandedChildren = flatten(children, value);\n            afNodesRef.value.splice(expandedNodeIndex + 1, 0, {\n              __motion: true,\n              mode: 'expand',\n              height: virtualScroll ? expandedChildren.length * nodeHeight : undefined,\n              nodes: virtualScroll ? expandedChildren.slice(0, viewportItemCount) : expandedChildren\n            });\n          }\n        }\n      }\n      if (removedKey !== null) {\n        const collapsedNodeIndex = afNodesRef.value.findIndex(node => node.key === removedKey);\n        if (~collapsedNodeIndex) {\n          const collapsedNodeChildren = afNodesRef.value[collapsedNodeIndex].children;\n          // Sometime the whole tree is change, remove a key doesn't mean it is collapsed,\n          // but maybe children removed\n          if (!collapsedNodeChildren) return;\n          // play remove animation\n          aipRef.value = true;\n          const collapsedChildren = flatten(collapsedNodeChildren, value);\n          afNodesRef.value.splice(collapsedNodeIndex + 1, 0, {\n            __motion: true,\n            mode: 'collapse',\n            height: virtualScroll ? collapsedChildren.length * nodeHeight : undefined,\n            nodes: virtualScroll ? collapsedChildren.slice(0, viewportItemCount) : collapsedChildren\n          });\n        }\n      }\n    });\n    const getFIndexRef = computed(() => {\n      return createIndexGetter(fNodesRef.value);\n    });\n    const mergedFNodesRef = computed(() => {\n      if (aipRef.value) return afNodesRef.value;else return fNodesRef.value;\n    });\n    function syncScrollbar() {\n      const {\n        value: scrollbarInst\n      } = scrollbarInstRef;\n      if (scrollbarInst) scrollbarInst.sync();\n    }\n    function handleAfterEnter() {\n      aipRef.value = false;\n      if (props.virtualScroll) {\n        // If virtual scroll, we won't listen to resize during animation, so\n        // resize callback of virtual list won't be called and as a result\n        // scrollbar won't sync. We need to sync scrollbar manually.\n        void nextTick(syncScrollbar);\n      }\n    }\n    function getOptionsByKeys(keys) {\n      const {\n        getNode\n      } = dataTreeMateRef.value;\n      return keys.map(key => {\n        var _a;\n        return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;\n      });\n    }\n    function doUpdateExpandedKeys(value, option, meta) {\n      const {\n        'onUpdate:expandedKeys': _onUpdateExpandedKeys,\n        onUpdateExpandedKeys\n      } = props;\n      uncontrolledExpandedKeysRef.value = value;\n      if (_onUpdateExpandedKeys) {\n        call(_onUpdateExpandedKeys, value, option, meta);\n      }\n      if (onUpdateExpandedKeys) {\n        call(onUpdateExpandedKeys, value, option, meta);\n      }\n    }\n    function doUpdateCheckedKeys(value, option, meta) {\n      const {\n        'onUpdate:checkedKeys': _onUpdateCheckedKeys,\n        onUpdateCheckedKeys\n      } = props;\n      uncontrolledCheckedKeysRef.value = value;\n      if (onUpdateCheckedKeys) {\n        call(onUpdateCheckedKeys, value, option, meta);\n      }\n      if (_onUpdateCheckedKeys) {\n        call(_onUpdateCheckedKeys, value, option, meta);\n      }\n    }\n    function doUpdateIndeterminateKeys(value, option) {\n      const {\n        'onUpdate:indeterminateKeys': _onUpdateIndeterminateKeys,\n        onUpdateIndeterminateKeys\n      } = props;\n      if (_onUpdateIndeterminateKeys) {\n        call(_onUpdateIndeterminateKeys, value, option);\n      }\n      if (onUpdateIndeterminateKeys) {\n        call(onUpdateIndeterminateKeys, value, option);\n      }\n    }\n    function doUpdateSelectedKeys(value, option, meta) {\n      const {\n        'onUpdate:selectedKeys': _onUpdateSelectedKeys,\n        onUpdateSelectedKeys\n      } = props;\n      uncontrolledSelectedKeysRef.value = value;\n      if (onUpdateSelectedKeys) {\n        call(onUpdateSelectedKeys, value, option, meta);\n      }\n      if (_onUpdateSelectedKeys) {\n        call(_onUpdateSelectedKeys, value, option, meta);\n      }\n    }\n    // Drag & Drop\n    function doDragEnter(info) {\n      const {\n        onDragenter\n      } = props;\n      if (onDragenter) call(onDragenter, info);\n    }\n    function doDragLeave(info) {\n      const {\n        onDragleave\n      } = props;\n      if (onDragleave) call(onDragleave, info);\n    }\n    function doDragEnd(info) {\n      const {\n        onDragend\n      } = props;\n      if (onDragend) call(onDragend, info);\n    }\n    function doDragStart(info) {\n      const {\n        onDragstart\n      } = props;\n      if (onDragstart) call(onDragstart, info);\n    }\n    function doDragOver(info) {\n      const {\n        onDragover\n      } = props;\n      if (onDragover) call(onDragover, info);\n    }\n    function doDrop(info) {\n      const {\n        onDrop\n      } = props;\n      if (onDrop) call(onDrop, info);\n    }\n    function resetDndState() {\n      resetDragState();\n      resetDropState();\n    }\n    function resetDragState() {\n      draggingNodeRef.value = null;\n    }\n    function resetDropState() {\n      droppingOffsetLevelRef.value = 0;\n      droppingNodeRef.value = null;\n      droppingMouseNodeRef.value = null;\n      droppingPositionRef.value = null;\n      resetDragExpandState();\n    }\n    function resetDragExpandState() {\n      if (expandTimerId) {\n        window.clearTimeout(expandTimerId);\n        expandTimerId = null;\n      }\n      nodeKeyToBeExpanded = null;\n    }\n    function handleCheck(node, checked) {\n      // We don't guard for leaf only since we have done it in view layer\n      if (props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      if (props.internalUnifySelectCheck && !props.multiple) {\n        handleSelect(node);\n        return;\n      }\n      const checkedAction = checked ? 'check' : 'uncheck';\n      const {\n        checkedKeys,\n        indeterminateKeys\n      } = dataTreeMateRef.value[checkedAction](node.key, displayedCheckedKeysRef.value, {\n        cascade: props.cascade,\n        checkStrategy: mergedCheckStrategyRef.value,\n        allowNotLoaded: props.allowCheckingNotLoaded\n      });\n      doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys), {\n        node: node.rawNode,\n        action: checkedAction\n      });\n      doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));\n    }\n    function toggleExpand(node) {\n      if (props.disabled) return;\n      const {\n        key\n      } = node;\n      const {\n        value: mergedExpandedKeys\n      } = mergedExpandedKeysRef;\n      const index = mergedExpandedKeys.findIndex(expandNodeId => expandNodeId === key);\n      if (~index) {\n        const expandedKeysAfterChange = Array.from(mergedExpandedKeys);\n        expandedKeysAfterChange.splice(index, 1);\n        doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), {\n          node: node.rawNode,\n          action: 'collapse'\n        });\n      } else {\n        const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);\n        if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {\n          return;\n        }\n        let nextKeys;\n        if (props.accordion) {\n          const siblingKeySet = new Set(node.siblings.map(({\n            key\n          }) => key));\n          nextKeys = mergedExpandedKeys.filter(expandedKey => {\n            return !siblingKeySet.has(expandedKey);\n          });\n          nextKeys.push(key);\n        } else {\n          nextKeys = mergedExpandedKeys.concat(key);\n        }\n        doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {\n          node: node.rawNode,\n          action: 'expand'\n        });\n      }\n    }\n    function handleSwitcherClick(node) {\n      if (props.disabled || aipRef.value) return;\n      toggleExpand(node);\n    }\n    function handleSelect(node) {\n      if (props.disabled || !props.selectable) {\n        return;\n      }\n      pendingNodeKeyRef.value = node.key;\n      if (props.internalUnifySelectCheck) {\n        const {\n          value: {\n            checkedKeys,\n            indeterminateKeys\n          }\n        } = checkedStatusRef;\n        if (props.multiple) {\n          handleCheck(node, !(checkedKeys.includes(node.key) || indeterminateKeys.includes(node.key)));\n        } else {\n          doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]), {\n            node: node.rawNode,\n            action: 'check'\n          });\n        }\n      }\n      if (props.multiple) {\n        const selectedKeys = Array.from(mergedSelectedKeysRef.value);\n        const index = selectedKeys.findIndex(key => key === node.key);\n        if (~index) {\n          if (props.cancelable) {\n            selectedKeys.splice(index, 1);\n          }\n        } else if (!~index) {\n          selectedKeys.push(node.key);\n        }\n        doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys), {\n          node: node.rawNode,\n          action: ~index ? 'unselect' : 'select'\n        });\n      } else {\n        const selectedKeys = mergedSelectedKeysRef.value;\n        if (selectedKeys.includes(node.key)) {\n          if (props.cancelable) {\n            doUpdateSelectedKeys([], [], {\n              node: node.rawNode,\n              action: 'unselect'\n            });\n          }\n        } else {\n          doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]), {\n            node: node.rawNode,\n            action: 'select'\n          });\n        }\n      }\n    }\n    function expandDragEnterNode(node) {\n      if (expandTimerId) {\n        window.clearTimeout(expandTimerId);\n        expandTimerId = null;\n      }\n      // Don't expand leaf node.\n      if (node.isLeaf) return;\n      nodeKeyToBeExpanded = node.key;\n      const expand = () => {\n        if (nodeKeyToBeExpanded !== node.key) return;\n        const {\n          value: droppingMouseNode\n        } = droppingMouseNodeRef;\n        if (droppingMouseNode && droppingMouseNode.key === node.key && !mergedExpandedKeysRef.value.includes(node.key)) {\n          const nextKeys = mergedExpandedKeysRef.value.concat(node.key);\n          doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {\n            node: node.rawNode,\n            action: 'expand'\n          });\n        }\n        expandTimerId = null;\n        nodeKeyToBeExpanded = null;\n      };\n      if (!node.shallowLoaded) {\n        expandTimerId = window.setTimeout(() => {\n          void triggerLoading(node).then(() => {\n            expand();\n          });\n        }, 1000);\n      } else {\n        expandTimerId = window.setTimeout(() => {\n          expand();\n        }, 1000);\n      }\n    }\n    // Dnd\n    function handleDragEnter({\n      event,\n      node\n    }) {\n      // node should be a tmNode\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      handleDragOver({\n        event,\n        node\n      }, false);\n      doDragEnter({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragLeave({\n      event,\n      node\n    }) {\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      doDragLeave({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragLeaveTree(e) {\n      if (e.target !== e.currentTarget) return;\n      resetDropState();\n    }\n    // Dragend is ok, we don't need to add global listener to reset drag status\n    function handleDragEnd({\n      event,\n      node\n    }) {\n      resetDndState();\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      doDragEnd({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragStart({\n      event,\n      node\n    }) {\n      var _a;\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      // Most of time, the image will block user's view\n      emptyImage && ((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.setDragImage(emptyImage, 0, 0));\n      dragStartX = event.clientX;\n      draggingNodeRef.value = node;\n      doDragStart({\n        event,\n        node: node.rawNode\n      });\n    }\n    function handleDragOver({\n      event,\n      node\n    }, emit = true) {\n      var _a;\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      const {\n        value: draggingNode\n      } = draggingNodeRef;\n      if (!draggingNode) return;\n      const {\n        allowDrop,\n        indent\n      } = props;\n      if (emit) doDragOver({\n        event,\n        node: node.rawNode\n      });\n      // Update dropping node\n      const el = event.currentTarget;\n      const {\n        height: elOffsetHeight,\n        top: elClientTop\n      } = el.getBoundingClientRect();\n      const eventOffsetY = event.clientY - elClientTop;\n      let mousePosition;\n      const allowDropInside = allowDrop({\n        node: node.rawNode,\n        dropPosition: 'inside',\n        phase: 'drag'\n      });\n      if (allowDropInside) {\n        if (eventOffsetY <= 8) {\n          mousePosition = 'before';\n        } else if (eventOffsetY >= elOffsetHeight - 8) {\n          mousePosition = 'after';\n        } else {\n          mousePosition = 'inside';\n        }\n      } else {\n        if (eventOffsetY <= elOffsetHeight / 2) {\n          mousePosition = 'before';\n        } else {\n          mousePosition = 'after';\n        }\n      }\n      const {\n        value: getFindex\n      } = getFIndexRef;\n      /** determine the drop position and drop node */\n      /** the dropping node needn't to be the mouse hovering node! */\n      /**\n       * if there is something i've learned from implementing a complex\n       * drag & drop. that is never write unit test before you really figure\n       * out what behavior is exactly you want.\n       */\n      let finalDropNode;\n      let finalDropPosition;\n      const hoverNodeFIndex = getFindex(node.key);\n      if (hoverNodeFIndex === null) {\n        resetDropState();\n        return;\n      }\n      let mouseAtExpandedNonLeafNode = false;\n      if (mousePosition === 'inside') {\n        finalDropNode = node;\n        finalDropPosition = 'inside';\n      } else {\n        if (mousePosition === 'before') {\n          if (node.isFirstChild) {\n            finalDropNode = node;\n            finalDropPosition = 'before';\n          } else {\n            finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];\n            finalDropPosition = 'after';\n          }\n        } else {\n          finalDropNode = node;\n          finalDropPosition = 'after';\n        }\n      }\n      // If the node is non-leaf and it is expanded, we don't allow it to\n      // drop after it and change it to drop before its next view sibling\n      if (!finalDropNode.isLeaf && mergedExpandedKeysRef.value.includes(finalDropNode.key)) {\n        mouseAtExpandedNonLeafNode = true;\n        if (finalDropPosition === 'after') {\n          finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];\n          if (!finalDropNode) {\n            // maybe there is no next view sibling when non-leaf node has no\n            // children and it is the last node in the tree\n            finalDropNode = node;\n            finalDropPosition = 'inside';\n          } else {\n            finalDropPosition = 'before';\n          }\n        }\n      }\n      const droppingMouseNode = finalDropNode;\n      droppingMouseNodeRef.value = droppingMouseNode;\n      // This is a speacial case, user is dragging a last child itself, so we\n      // only view it as they are trying to drop after it.\n      // There are some relevant codes in bailout 1's child branch.\n      // Also, the expand bailout should have a high priority. If it's non-leaf\n      // node and expanded, keep its origin drop position\n      if (!mouseAtExpandedNonLeafNode && draggingNode.isLastChild && draggingNode.key === finalDropNode.key) {\n        finalDropPosition = 'after';\n      }\n      if (finalDropPosition === 'after') {\n        let offset = dragStartX - event.clientX; // drag left => > 0\n        let offsetLevel = 0;\n        while (offset >= indent / 2 &&\n        // divide by 2 to make it easier to trigger\n        finalDropNode.parent !== null && finalDropNode.isLastChild && offsetLevel < 1) {\n          offset -= indent;\n          offsetLevel += 1;\n          finalDropNode = finalDropNode.parent;\n        }\n        droppingOffsetLevelRef.value = offsetLevel;\n      } else {\n        droppingOffsetLevelRef.value = 0;\n      }\n      // Bailout 1\n      // Drag self into self\n      // Drag it into direct parent\n      if (draggingNode.contains(finalDropNode) || finalDropPosition === 'inside' && ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key) {\n        if (draggingNode.key === droppingMouseNode.key && draggingNode.key === finalDropNode.key) {\n          // This is special case that we want ui to show a mark to guide user\n          // to start dragging. Nor they will think nothing happens.\n          // However this is an invalid drop, we need to guard it inside\n          // handleDrop\n        } else {\n          resetDropState();\n          return;\n        }\n      }\n      // Bailout 3\n      if (!allowDrop({\n        node: finalDropNode.rawNode,\n        dropPosition: finalDropPosition,\n        phase: 'drag'\n      })) {\n        resetDropState();\n        return;\n      }\n      if (draggingNode.key === finalDropNode.key) {\n        // don't expand when drag on itself\n        resetDragExpandState();\n      } else {\n        if (nodeKeyToBeExpanded !== finalDropNode.key) {\n          if (finalDropPosition === 'inside') {\n            if (props.expandOnDragenter) {\n              expandDragEnterNode(finalDropNode);\n              // Bailout 4\n              // not try to loading\n              if (!finalDropNode.shallowLoaded && nodeKeyToBeExpanded !== finalDropNode.key) {\n                resetDndState();\n                return;\n              }\n            } else {\n              // Bailout 5\n              // never expands on drag\n              if (!finalDropNode.shallowLoaded) {\n                resetDndState();\n                return;\n              }\n            }\n          } else {\n            resetDragExpandState();\n          }\n        } else {\n          if (finalDropPosition !== 'inside') {\n            resetDragExpandState();\n          }\n        }\n      }\n      droppingPositionRef.value = finalDropPosition;\n      droppingNodeRef.value = finalDropNode;\n    }\n    function handleDrop({\n      event,\n      node,\n      dropPosition\n    }) {\n      if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {\n        return;\n      }\n      const {\n        value: draggingNode\n      } = draggingNodeRef;\n      const {\n        value: droppingNode\n      } = droppingNodeRef;\n      const {\n        value: droppingPosition\n      } = droppingPositionRef;\n      if (!draggingNode || !droppingNode || !droppingPosition) {\n        return;\n      }\n      // Bailout 1\n      if (!props.allowDrop({\n        node: droppingNode.rawNode,\n        dropPosition: droppingPosition,\n        phase: 'drag'\n      })) {\n        return;\n      }\n      // Bailout 2\n      // This is a special case to guard since we want ui to show the status\n      // but not to emit a event\n      if (draggingNode.key === droppingNode.key) {\n        return;\n      }\n      // Bailout 3\n      // insert before its next node\n      // insert after its prev node\n      if (droppingPosition === 'before') {\n        const nextNode = draggingNode.getNext({\n          includeDisabled: true\n        });\n        if (nextNode) {\n          if (nextNode.key === droppingNode.key) {\n            resetDropState();\n            return;\n          }\n        }\n      }\n      if (droppingPosition === 'after') {\n        const prevNode = draggingNode.getPrev({\n          includeDisabled: true\n        });\n        if (prevNode) {\n          if (prevNode.key === droppingNode.key) {\n            resetDropState();\n            return;\n          }\n        }\n      }\n      doDrop({\n        event,\n        node: droppingNode.rawNode,\n        dragNode: draggingNode.rawNode,\n        dropPosition\n      });\n      resetDndState();\n    }\n    function handleScroll() {\n      syncScrollbar();\n    }\n    function handleResize() {\n      syncScrollbar();\n    }\n    function handleFocusout(e) {\n      var _a;\n      if (props.virtualScroll || props.internalScrollable) {\n        const {\n          value: scrollbarInst\n        } = scrollbarInstRef;\n        if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {\n          return;\n        }\n        pendingNodeKeyRef.value = null;\n      } else {\n        const {\n          value: selfEl\n        } = selfElRef;\n        if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget)) return;\n        pendingNodeKeyRef.value = null;\n      }\n    }\n    watch(pendingNodeKeyRef, value => {\n      var _a, _b;\n      if (value === null) return;\n      if (props.virtualScroll) {\n        (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({\n          key: value\n        });\n      } else if (props.internalScrollable) {\n        const {\n          value: scrollbarInst\n        } = scrollbarInstRef;\n        if (scrollbarInst === null) return;\n        const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key=\"${createDataKey(value)}\"]`);\n        if (!targetEl) return;\n        scrollbarInst.scrollTo({\n          el: targetEl\n        });\n      }\n    });\n    provide(treeInjectionKey, {\n      loadingKeysRef,\n      highlightKeySetRef: mergedHighlightKeySetRef,\n      displayedCheckedKeysRef,\n      displayedIndeterminateKeysRef,\n      mergedSelectedKeysRef,\n      mergedExpandedKeysRef,\n      mergedThemeRef: themeRef,\n      mergedCheckStrategyRef,\n      nodePropsRef: toRef(props, 'nodeProps'),\n      disabledRef: toRef(props, 'disabled'),\n      checkableRef: toRef(props, 'checkable'),\n      selectableRef: toRef(props, 'selectable'),\n      expandOnClickRef: toRef(props, 'expandOnClick'),\n      onLoadRef: toRef(props, 'onLoad'),\n      draggableRef: toRef(props, 'draggable'),\n      blockLineRef: toRef(props, 'blockLine'),\n      indentRef: toRef(props, 'indent'),\n      cascadeRef: toRef(props, 'cascade'),\n      checkOnClickRef: toRef(props, 'checkOnClick'),\n      checkboxPlacementRef: props.checkboxPlacement,\n      droppingMouseNodeRef,\n      droppingNodeParentRef,\n      draggingNodeRef,\n      droppingPositionRef,\n      droppingOffsetLevelRef,\n      fNodesRef,\n      pendingNodeKeyRef,\n      showLineRef: toRef(props, 'showLine'),\n      disabledFieldRef: toRef(props, 'disabledField'),\n      internalScrollableRef: toRef(props, 'internalScrollable'),\n      internalCheckboxFocusableRef: toRef(props, 'internalCheckboxFocusable'),\n      internalTreeSelect: props.internalTreeSelect,\n      renderLabelRef: toRef(props, 'renderLabel'),\n      renderPrefixRef: toRef(props, 'renderPrefix'),\n      renderSuffixRef: toRef(props, 'renderSuffix'),\n      renderSwitcherIconRef: toRef(props, 'renderSwitcherIcon'),\n      labelFieldRef: toRef(props, 'labelField'),\n      multipleRef: toRef(props, 'multiple'),\n      handleSwitcherClick,\n      handleDragEnd,\n      handleDragEnter,\n      handleDragLeave,\n      handleDragStart,\n      handleDrop,\n      handleDragOver,\n      handleSelect,\n      handleCheck\n    });\n    function scrollTo(options) {\n      var _a;\n      (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options);\n    }\n    const exposedMethods = {\n      handleKeydown,\n      scrollTo,\n      getCheckedData: () => {\n        if (!props.checkable) return {\n          keys: [],\n          options: []\n        };\n        const {\n          checkedKeys\n        } = checkedStatusRef.value;\n        return {\n          keys: checkedKeys,\n          options: getOptionsByKeys(checkedKeys)\n        };\n      },\n      getIndeterminateData: () => {\n        if (!props.checkable) return {\n          keys: [],\n          options: []\n        };\n        const {\n          indeterminateKeys\n        } = checkedStatusRef.value;\n        return {\n          keys: indeterminateKeys,\n          options: getOptionsByKeys(indeterminateKeys)\n        };\n      }\n    };\n    const cssVarsRef = computed(() => {\n      const {\n        common: {\n          cubicBezierEaseInOut\n        },\n        self: {\n          fontSize,\n          nodeBorderRadius,\n          nodeColorHover,\n          nodeColorPressed,\n          nodeColorActive,\n          arrowColor,\n          loadingColor,\n          nodeTextColor,\n          nodeTextColorDisabled,\n          dropMarkColor,\n          nodeWrapperPadding,\n          nodeHeight,\n          lineHeight,\n          lineColor\n        }\n      } = themeRef.value;\n      const lineOffsetTop = getPadding(nodeWrapperPadding, 'top');\n      const lineOffsetBottom = getPadding(nodeWrapperPadding, 'bottom');\n      const nodeContentHeight = pxfy(depx(nodeHeight) - depx(lineOffsetTop) - depx(lineOffsetBottom));\n      return {\n        '--n-arrow-color': arrowColor,\n        '--n-loading-color': loadingColor,\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-font-size': fontSize,\n        '--n-node-border-radius': nodeBorderRadius,\n        '--n-node-color-active': nodeColorActive,\n        '--n-node-color-hover': nodeColorHover,\n        '--n-node-color-pressed': nodeColorPressed,\n        '--n-node-text-color': nodeTextColor,\n        '--n-node-text-color-disabled': nodeTextColorDisabled,\n        '--n-drop-mark-color': dropMarkColor,\n        '--n-node-wrapper-padding': nodeWrapperPadding,\n        '--n-line-offset-top': `-${lineOffsetTop}`,\n        '--n-line-offset-bottom': `-${lineOffsetBottom}`,\n        '--n-node-content-height': nodeContentHeight,\n        '--n-line-height': lineHeight,\n        '--n-line-color': lineColor\n      };\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('tree', undefined, cssVarsRef, props) : undefined;\n    return Object.assign(Object.assign({}, exposedMethods), {\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedTheme: themeRef,\n      rtlEnabled: rtlEnabledRef,\n      fNodes: mergedFNodesRef,\n      aip: aipRef,\n      selfElRef,\n      virtualListInstRef,\n      scrollbarInstRef,\n      handleFocusout,\n      handleDragLeaveTree,\n      handleScroll,\n      getScrollContainer,\n      getScrollContent,\n      handleAfterEnter,\n      handleResize,\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    });\n  },\n  render() {\n    var _a;\n    const {\n      fNodes,\n      internalRenderEmpty\n    } = this;\n    if (!fNodes.length && internalRenderEmpty) {\n      return internalRenderEmpty();\n    }\n    const {\n      mergedClsPrefix,\n      blockNode,\n      blockLine,\n      draggable,\n      disabled,\n      internalFocusable,\n      checkable,\n      handleKeydown,\n      rtlEnabled,\n      handleFocusout,\n      scrollbarProps\n    } = this;\n    const mergedFocusable = internalFocusable && !disabled;\n    const tabindex = mergedFocusable ? '0' : undefined;\n    const treeClass = [`${mergedClsPrefix}-tree`, rtlEnabled && `${mergedClsPrefix}-tree--rtl`, checkable && `${mergedClsPrefix}-tree--checkable`, (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`, blockLine && `${mergedClsPrefix}-tree--block-line`];\n    const createNode = tmNode => {\n      return '__motion' in tmNode ? h(MotionWrapper, {\n        height: tmNode.height,\n        nodes: tmNode.nodes,\n        clsPrefix: mergedClsPrefix,\n        mode: tmNode.mode,\n        onAfterEnter: this.handleAfterEnter\n      }) : h(NTreeNode, {\n        key: tmNode.key,\n        tmNode: tmNode,\n        clsPrefix: mergedClsPrefix\n      });\n    };\n    if (this.virtualScroll) {\n      const {\n        mergedTheme,\n        internalScrollablePadding\n      } = this;\n      const padding = getPadding(internalScrollablePadding || '0');\n      return h(NxScrollbar, Object.assign({}, scrollbarProps, {\n        ref: \"scrollbarInstRef\",\n        onDragleave: draggable ? this.handleDragLeaveTree : undefined,\n        container: this.getScrollContainer,\n        content: this.getScrollContent,\n        class: treeClass,\n        theme: mergedTheme.peers.Scrollbar,\n        themeOverrides: mergedTheme.peerOverrides.Scrollbar,\n        tabindex: tabindex,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined\n      }), {\n        default: () => {\n          var _a;\n          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n          return !fNodes.length ? resolveSlot(this.$slots.empty, () => [h(NEmpty, {\n            class: `${mergedClsPrefix}-tree__empty`,\n            theme: this.mergedTheme.peers.Empty,\n            themeOverrides: this.mergedTheme.peerOverrides.Empty\n          })]) : h(VVirtualList, {\n            ref: \"virtualListInstRef\",\n            items: this.fNodes,\n            itemSize: depx(mergedTheme.self.nodeHeight),\n            ignoreItemResize: this.aip,\n            paddingTop: padding.top,\n            paddingBottom: padding.bottom,\n            class: this.themeClass,\n            style: [this.cssVars, {\n              paddingLeft: padding.left,\n              paddingRight: padding.right\n            }],\n            onScroll: this.handleScroll,\n            onResize: this.handleResize,\n            showScrollbar: false,\n            itemResizable: true\n          }, {\n            default: ({\n              item\n            }) => createNode(item)\n          });\n        }\n      });\n    }\n    const {\n      internalScrollable\n    } = this;\n    treeClass.push(this.themeClass);\n    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n    if (internalScrollable) {\n      return h(NxScrollbar, Object.assign({}, scrollbarProps, {\n        class: treeClass,\n        tabindex: tabindex,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined,\n        style: this.cssVars,\n        contentStyle: {\n          padding: this.internalScrollablePadding\n        }\n      }), {\n        default: () => h(\"div\", {\n          onDragleave: draggable ? this.handleDragLeaveTree : undefined,\n          ref: \"selfElRef\"\n        }, this.fNodes.map(createNode))\n      });\n    } else {\n      return h(\"div\", {\n        class: treeClass,\n        tabindex: tabindex,\n        ref: \"selfElRef\",\n        style: this.cssVars,\n        onKeydown: mergedFocusable ? handleKeydown : undefined,\n        onFocusout: mergedFocusable ? handleFocusout : undefined,\n        onDragleave: draggable ? this.handleDragLeaveTree : undefined\n      }, !fNodes.length ? resolveSlot(this.$slots.empty, () => [h(NEmpty, {\n        class: `${mergedClsPrefix}-tree__empty`,\n        theme: this.mergedTheme.peers.Empty,\n        themeOverrides: this.mergedTheme.peerOverrides.Empty\n      })]) : fNodes.map(createNode));\n    }\n  }\n});","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","h","ref","toRef","computed","defineComponent","provide","watch","nextTick","watchEffect","inject","createTreeMate","flatten","createIndexGetter","useMergedState","VVirtualList","depx","getPadding","pxfy","treeSelectInjectionKey","useConfig","useTheme","useThemeClass","useRtl","call","createDataKey","resolveSlot","warn","warnOnce","NxScrollbar","treeLight","NEmpty","NTreeNode","keysWithFilter","emptyImage","filterTree","isNodeDisabled","useMergedCheckStrategy","useKeyboard","treeInjectionKey","MotionWrapper","defaultAllowDrop","style","createTreeMateOptions","keyField","childrenField","disabledField","getChildren","settledGetChildren","node","getIsGroup","getKey","getDisabled","checkboxDisabled","treeSharedProps","allowCheckingNotLoaded","Boolean","filter","Function","defaultExpandAll","expandedKeys","Array","type","String","default","labelField","defaultExpandedKeys","indeterminateKeys","renderSwitcherIcon","onUpdateIndeterminateKeys","onUpdateExpandedKeys","treeProps","Object","assign","props","accordion","showIrrelevantNodes","data","expandOnDragenter","expandOnClick","checkOnClick","cancelable","checkable","draggable","blockNode","blockLine","showLine","disabled","checkedKeys","defaultCheckedKeys","selectedKeys","defaultSelectedKeys","multiple","pattern","onLoad","cascade","selectable","scrollbarProps","indent","Number","allowDrop","animated","checkboxPlacement","virtualScroll","watchProps","renderLabel","renderPrefix","renderSuffix","nodeProps","keyboard","onDragenter","onDragleave","onDragend","onDragstart","onDragover","onDrop","onUpdateCheckedKeys","onUpdateSelectedKeys","internalTreeSelect","internalScrollable","internalScrollablePadding","internalRenderEmpty","internalHighlightKeySet","internalUnifySelectCheck","internalCheckboxFocusable","internalFocusable","checkStrategy","leafOnly","name","setup","process","env","NODE_ENV","mergedClsPrefixRef","inlineThemeDisabled","mergedRtlRef","rtlEnabledRef","themeRef","selfElRef","scrollbarInstRef","virtualListInstRef","getScrollContainer","_a","listElRef","getScrollContent","itemsElRef","mergedFilterRef","length","label","toLowerCase","includes","filteredTreeInfoRef","filteredTree","highlightKeySet","undefined","displayTreeMateRef","treeSelectInjection","dataTreeMateRef","dataTreeMate","uncontrolledCheckedKeysRef","controlledCheckedKeysRef","mergedCheckedKeysRef","checkedStatusRef","getCheckedKeys","allowNotLoaded","mergedCheckStrategyRef","displayedCheckedKeysRef","displayedIndeterminateKeysRef","uncontrolledSelectedKeysRef","controlledSelectedKeysRef","mergedSelectedKeysRef","uncontrolledExpandedKeysRef","initUncontrolledExpandedKeys","keys","getNonLeafKeys","controlledExpandedKeysRef","mergedExpandedKeysRef","fNodesRef","getFlattenedNodes","pendingNodeKeyRef","handleKeydown","handleSelect","handleSwitcherClick","expandTimerId","nodeKeyToBeExpanded","uncontrolledHighlightKeySetRef","Set","controlledHighlightKeySetRef","mergedHighlightKeySetRef","loadingKeysRef","expandedNonLoadingKeysRef","key","has","dragStartX","draggingNodeRef","droppingNodeRef","droppingMouseNodeRef","droppingPositionRef","droppingOffsetLevelRef","droppingNodeParentRef","droppingNode","parent","clear","resetDndState","deep","expandAnimationDisabled","disableExpandAnimationForOneTick","memoizedExpandedKeys","oldValue","expandedKeysAfterChange","doUpdateExpandedKeys","getOptionsByKeys","action","triggerLoading","loadingKeys","add","loadResult","rawNode","resetDragExpandState","loadError","console","error","delete","displayTreeMate","getNode","forEach","shallowLoaded","aipRef","afNodesRef","prevValue","syncScrollbar","nodeHeight","self","prevVSet","addedKey","removedKey","expandedKey","currentVSet","viewportHeight","offsetHeight","viewportItemCount","Math","ceil","baseExpandedKeys","expandedNodeIndex","findIndex","children","expandedChildren","splice","__motion","mode","height","nodes","slice","collapsedNodeIndex","collapsedNodeChildren","collapsedChildren","getFIndexRef","mergedFNodesRef","scrollbarInst","sync","handleAfterEnter","map","option","meta","_onUpdateExpandedKeys","doUpdateCheckedKeys","_onUpdateCheckedKeys","doUpdateIndeterminateKeys","_onUpdateIndeterminateKeys","doUpdateSelectedKeys","_onUpdateSelectedKeys","doDragEnter","info","doDragLeave","doDragEnd","doDragStart","doDragOver","doDrop","resetDragState","resetDropState","window","clearTimeout","handleCheck","checked","checkedAction","toggleExpand","mergedExpandedKeys","index","expandNodeId","from","nodeToBeExpanded","isLeaf","nextKeys","siblingKeySet","siblings","push","concat","expandDragEnterNode","expand","droppingMouseNode","setTimeout","handleDragEnter","event","handleDragOver","handleDragLeave","handleDragLeaveTree","target","currentTarget","handleDragEnd","handleDragStart","dataTransfer","setDragImage","clientX","emit","draggingNode","el","elOffsetHeight","top","elClientTop","getBoundingClientRect","eventOffsetY","clientY","mousePosition","allowDropInside","dropPosition","phase","getFindex","finalDropNode","finalDropPosition","hoverNodeFIndex","mouseAtExpandedNonLeafNode","isFirstChild","isLastChild","offset","offsetLevel","contains","handleDrop","droppingPosition","nextNode","getNext","includeDisabled","prevNode","getPrev","dragNode","handleScroll","handleResize","handleFocusout","containerRef","relatedTarget","selfEl","_b","scrollTo","targetEl","contentRef","querySelector","highlightKeySetRef","mergedThemeRef","nodePropsRef","disabledRef","checkableRef","selectableRef","expandOnClickRef","onLoadRef","draggableRef","blockLineRef","indentRef","cascadeRef","checkOnClickRef","checkboxPlacementRef","showLineRef","disabledFieldRef","internalScrollableRef","internalCheckboxFocusableRef","renderLabelRef","renderPrefixRef","renderSuffixRef","renderSwitcherIconRef","labelFieldRef","multipleRef","options","exposedMethods","getCheckedData","getIndeterminateData","cssVarsRef","common","cubicBezierEaseInOut","fontSize","nodeBorderRadius","nodeColorHover","nodeColorPressed","nodeColorActive","arrowColor","loadingColor","nodeTextColor","nodeTextColorDisabled","dropMarkColor","nodeWrapperPadding","lineHeight","lineColor","lineOffsetTop","lineOffsetBottom","nodeContentHeight","themeClassHandle","mergedClsPrefix","mergedTheme","rtlEnabled","fNodes","aip","cssVars","themeClass","onRender","render","mergedFocusable","tabindex","treeClass","createNode","tmNode","clsPrefix","onAfterEnter","padding","container","content","class","theme","peers","Scrollbar","themeOverrides","peerOverrides","onKeydown","onFocusout","$slots","empty","Empty","items","itemSize","ignoreItemResize","paddingTop","paddingBottom","bottom","paddingLeft","left","paddingRight","right","onScroll","onResize","showScrollbar","itemResizable","item","contentStyle"],"sources":["/home/whw/Vue/whwtest.github.io/node_modules/naive-ui/es/tree/src/Tree.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { h, ref, toRef, computed, defineComponent, provide, watch, nextTick, watchEffect, inject } from 'vue';\nimport { createTreeMate, flatten, createIndexGetter } from 'treemate';\nimport { useMergedState } from 'vooks';\nimport { VVirtualList } from 'vueuc';\nimport { depx, getPadding, pxfy } from 'seemly';\nimport { treeSelectInjectionKey } from '../../tree-select/src/interface';\nimport { useConfig, useTheme, useThemeClass, useRtl } from '../../_mixins';\nimport { call, createDataKey, resolveSlot, warn, warnOnce } from '../../_utils';\nimport { NxScrollbar } from '../../_internal';\nimport { treeLight } from '../styles';\nimport { NEmpty } from '../../empty';\nimport NTreeNode from './TreeNode';\nimport { keysWithFilter, emptyImage, filterTree, isNodeDisabled, useMergedCheckStrategy } from './utils';\nimport { useKeyboard } from './keyboard';\nimport { treeInjectionKey } from './interface';\nimport MotionWrapper from './MotionWrapper';\nimport { defaultAllowDrop } from './dnd';\nimport style from './styles/index.cssr';\nexport function createTreeMateOptions(keyField, childrenField, disabledField, getChildren) {\n    const settledGetChildren = getChildren ||\n        ((node) => {\n            return node[childrenField];\n        });\n    return {\n        getIsGroup() {\n            return false;\n        },\n        getKey(node) {\n            return node[keyField];\n        },\n        getChildren: settledGetChildren,\n        getDisabled(node) {\n            return !!(node[disabledField] || node.checkboxDisabled);\n        }\n    };\n}\nexport const treeSharedProps = {\n    allowCheckingNotLoaded: Boolean,\n    filter: Function,\n    defaultExpandAll: Boolean,\n    expandedKeys: Array,\n    keyField: {\n        type: String,\n        default: 'key'\n    },\n    labelField: {\n        type: String,\n        default: 'label'\n    },\n    childrenField: {\n        type: String,\n        default: 'children'\n    },\n    disabledField: {\n        type: String,\n        default: 'disabled'\n    },\n    defaultExpandedKeys: {\n        type: Array,\n        default: () => []\n    },\n    indeterminateKeys: Array,\n    renderSwitcherIcon: Function,\n    onUpdateIndeterminateKeys: [Function, Array],\n    'onUpdate:indeterminateKeys': [Function, Array],\n    onUpdateExpandedKeys: [Function, Array],\n    'onUpdate:expandedKeys': [Function, Array]\n};\nexport const treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), { accordion: Boolean, showIrrelevantNodes: { type: Boolean, default: true }, data: {\n        type: Array,\n        default: () => []\n    }, expandOnDragenter: {\n        type: Boolean,\n        default: true\n    }, expandOnClick: Boolean, checkOnClick: {\n        type: [Boolean, Function],\n        default: false\n    }, cancelable: {\n        type: Boolean,\n        default: true\n    }, checkable: Boolean, draggable: Boolean, blockNode: Boolean, blockLine: Boolean, showLine: Boolean, disabled: Boolean, checkedKeys: Array, defaultCheckedKeys: {\n        type: Array,\n        default: () => []\n    }, selectedKeys: Array, defaultSelectedKeys: {\n        type: Array,\n        default: () => []\n    }, multiple: Boolean, pattern: {\n        type: String,\n        default: ''\n    }, onLoad: Function, cascade: Boolean, selectable: {\n        type: Boolean,\n        default: true\n    }, scrollbarProps: Object, indent: {\n        type: Number,\n        default: 24\n    }, allowDrop: {\n        type: Function,\n        default: defaultAllowDrop\n    }, animated: {\n        type: Boolean,\n        default: true\n    }, checkboxPlacement: {\n        type: String,\n        default: 'left'\n    }, virtualScroll: Boolean, watchProps: Array, renderLabel: Function, renderPrefix: Function, renderSuffix: Function, nodeProps: Function, keyboard: {\n        type: Boolean,\n        default: true\n    }, getChildren: Function, onDragenter: [Function, Array], onDragleave: [Function, Array], onDragend: [Function, Array], onDragstart: [Function, Array], onDragover: [Function, Array], onDrop: [Function, Array], onUpdateCheckedKeys: [Function, Array], 'onUpdate:checkedKeys': [Function, Array], onUpdateSelectedKeys: [Function, Array], 'onUpdate:selectedKeys': [Function, Array] }), treeSharedProps), { \n    // internal props for tree-select\n    internalTreeSelect: Boolean, internalScrollable: Boolean, internalScrollablePadding: String, \n    // use it to display\n    internalRenderEmpty: Function, internalHighlightKeySet: Object, internalUnifySelectCheck: Boolean, internalCheckboxFocusable: {\n        type: Boolean,\n        default: true\n    }, internalFocusable: {\n        // Make tree-select take over keyboard operations\n        type: Boolean,\n        default: true\n    }, checkStrategy: {\n        type: String,\n        default: 'all'\n    }, \n    /**\n     * @deprecated\n     */\n    leafOnly: Boolean });\nexport default defineComponent({\n    name: 'Tree',\n    props: treeProps,\n    setup(props) {\n        if (process.env.NODE_ENV !== 'production') {\n            watchEffect(() => {\n                if (props.leafOnly) {\n                    warnOnce('tree', '`leaf-only` is deprecated, please use `check-strategy=\"child\"` instead');\n                }\n            });\n        }\n        const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);\n        const rtlEnabledRef = useRtl('Tree', mergedRtlRef, mergedClsPrefixRef);\n        const themeRef = useTheme('Tree', '-tree', style, treeLight, props, mergedClsPrefixRef);\n        const selfElRef = ref(null);\n        const scrollbarInstRef = ref(null);\n        const virtualListInstRef = ref(null);\n        function getScrollContainer() {\n            var _a;\n            return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;\n        }\n        function getScrollContent() {\n            var _a;\n            return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;\n        }\n        const mergedFilterRef = computed(() => {\n            const { filter } = props;\n            if (filter)\n                return filter;\n            const { labelField } = props;\n            return (pattern, node) => {\n                if (!pattern.length)\n                    return true;\n                const label = node[labelField];\n                if (typeof label === 'string') {\n                    return label.toLowerCase().includes(pattern.toLowerCase());\n                }\n                return false;\n            };\n        });\n        const filteredTreeInfoRef = computed(() => {\n            const { pattern } = props;\n            if (!pattern) {\n                return {\n                    filteredTree: props.data,\n                    highlightKeySet: null,\n                    expandedKeys: undefined\n                };\n            }\n            if (!pattern.length || !mergedFilterRef.value) {\n                return {\n                    filteredTree: props.data,\n                    highlightKeySet: null,\n                    expandedKeys: undefined\n                };\n            }\n            return filterTree(props.data, mergedFilterRef.value, pattern, props.keyField, props.childrenField);\n        });\n        // We don't expect data source to change so we just determine it once\n        const displayTreeMateRef = computed(() => createTreeMate(props.showIrrelevantNodes\n            ? props.data\n            : filteredTreeInfoRef.value.filteredTree, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField, props.getChildren)));\n        const treeSelectInjection = inject(treeSelectInjectionKey, null);\n        const dataTreeMateRef = props.internalTreeSelect\n            ? treeSelectInjection.dataTreeMate\n            : displayTreeMateRef;\n        const { watchProps } = props;\n        const uncontrolledCheckedKeysRef = ref([]);\n        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultCheckedKeys')) {\n            watchEffect(() => {\n                uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n            });\n        }\n        else {\n            uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;\n        }\n        const controlledCheckedKeysRef = toRef(props, 'checkedKeys');\n        const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);\n        const checkedStatusRef = computed(() => {\n            const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {\n                cascade: props.cascade,\n                allowNotLoaded: props.allowCheckingNotLoaded\n            });\n            return value;\n        });\n        const mergedCheckStrategyRef = useMergedCheckStrategy(props);\n        const displayedCheckedKeysRef = computed(() => {\n            return checkedStatusRef.value.checkedKeys;\n        });\n        const displayedIndeterminateKeysRef = computed(() => {\n            const { indeterminateKeys } = props;\n            if (indeterminateKeys !== undefined)\n                return indeterminateKeys;\n            return checkedStatusRef.value.indeterminateKeys;\n        });\n        const uncontrolledSelectedKeysRef = ref([]);\n        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultSelectedKeys')) {\n            watchEffect(() => {\n                uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n            });\n        }\n        else {\n            uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;\n        }\n        const controlledSelectedKeysRef = toRef(props, 'selectedKeys');\n        const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);\n        const uncontrolledExpandedKeysRef = ref([]);\n        const initUncontrolledExpandedKeys = (keys) => {\n            uncontrolledExpandedKeysRef.value = props.defaultExpandAll\n                ? dataTreeMateRef.value.getNonLeafKeys()\n                : keys === undefined\n                    ? props.defaultExpandedKeys\n                    : keys;\n        };\n        if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {\n            // if watching defaultExpandedKeys, we use access props.defaultExpandedKeys inside initiator\n            watchEffect(() => {\n                initUncontrolledExpandedKeys(undefined);\n            });\n        }\n        else {\n            // We by default watchEffect since if defaultExpandAll is true, we should remain tree expand if data changes\n            watchEffect(() => {\n                initUncontrolledExpandedKeys(props.defaultExpandedKeys);\n            });\n        }\n        const controlledExpandedKeysRef = toRef(props, 'expandedKeys');\n        const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);\n        const fNodesRef = computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));\n        const { pendingNodeKeyRef, handleKeydown } = useKeyboard({\n            props,\n            mergedSelectedKeysRef,\n            fNodesRef,\n            mergedExpandedKeysRef,\n            handleSelect,\n            handleSwitcherClick\n        });\n        let expandTimerId = null;\n        let nodeKeyToBeExpanded = null;\n        const uncontrolledHighlightKeySetRef = ref(new Set());\n        const controlledHighlightKeySetRef = computed(() => {\n            return (props.internalHighlightKeySet ||\n                filteredTreeInfoRef.value.highlightKeySet);\n        });\n        const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);\n        const loadingKeysRef = ref(new Set());\n        const expandedNonLoadingKeysRef = computed(() => {\n            return mergedExpandedKeysRef.value.filter((key) => !loadingKeysRef.value.has(key));\n        });\n        let dragStartX = 0;\n        const draggingNodeRef = ref(null);\n        const droppingNodeRef = ref(null);\n        const droppingMouseNodeRef = ref(null);\n        const droppingPositionRef = ref(null);\n        const droppingOffsetLevelRef = ref(0);\n        const droppingNodeParentRef = computed(() => {\n            const { value: droppingNode } = droppingNodeRef;\n            if (!droppingNode)\n                return null;\n            // May avoid overlap between line mark of first child & rect mark of parent\n            // if (droppingNode.isFirstChild && droppingPositionRef.value === 'before') {\n            //   return null\n            // }\n            return droppingNode.parent;\n        });\n        // shallow watch data\n        watch(toRef(props, 'data'), () => {\n            loadingKeysRef.value.clear();\n            pendingNodeKeyRef.value = null;\n            resetDndState();\n        }, {\n            deep: false\n        });\n        let expandAnimationDisabled = false;\n        const disableExpandAnimationForOneTick = () => {\n            expandAnimationDisabled = true;\n            void nextTick(() => {\n                expandAnimationDisabled = false;\n            });\n        };\n        let memoizedExpandedKeys;\n        watch(toRef(props, 'pattern'), (value, oldValue) => {\n            if (props.showIrrelevantNodes) {\n                memoizedExpandedKeys = undefined;\n                if (value) {\n                    const { expandedKeys: expandedKeysAfterChange, highlightKeySet } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);\n                    uncontrolledHighlightKeySetRef.value = highlightKeySet;\n                    disableExpandAnimationForOneTick();\n                    doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), { node: null, action: 'filter' });\n                }\n                else {\n                    uncontrolledHighlightKeySetRef.value = new Set();\n                }\n            }\n            else {\n                if (!value.length) {\n                    if (memoizedExpandedKeys !== undefined) {\n                        disableExpandAnimationForOneTick();\n                        doUpdateExpandedKeys(memoizedExpandedKeys, getOptionsByKeys(memoizedExpandedKeys), { node: null, action: 'filter' });\n                    }\n                }\n                else {\n                    if (!oldValue.length) {\n                        memoizedExpandedKeys = mergedExpandedKeysRef.value;\n                    }\n                    const { expandedKeys } = filteredTreeInfoRef.value;\n                    if (expandedKeys !== undefined) {\n                        disableExpandAnimationForOneTick();\n                        doUpdateExpandedKeys(expandedKeys, getOptionsByKeys(expandedKeys), {\n                            node: null,\n                            action: 'filter'\n                        });\n                    }\n                }\n            }\n        });\n        function triggerLoading(node) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const { onLoad } = props;\n                if (!onLoad) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        warn('tree', 'There is unloaded node in data but props.onLoad is not specified.');\n                    }\n                    yield Promise.resolve();\n                    return;\n                }\n                const { value: loadingKeys } = loadingKeysRef;\n                if (!loadingKeys.has(node.key)) {\n                    loadingKeys.add(node.key);\n                    try {\n                        const loadResult = yield onLoad(node.rawNode);\n                        if (loadResult === false) {\n                            resetDragExpandState();\n                        }\n                    }\n                    catch (loadError) {\n                        console.error(loadError);\n                        resetDragExpandState();\n                    }\n                    loadingKeys.delete(node.key);\n                }\n            });\n        }\n        watchEffect(() => {\n            var _a;\n            const { value: displayTreeMate } = displayTreeMateRef;\n            if (!displayTreeMate)\n                return;\n            const { getNode } = displayTreeMate;\n            (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach((key) => {\n                const node = getNode(key);\n                if (node && !node.shallowLoaded) {\n                    void triggerLoading(node);\n                }\n            });\n        });\n        // animation in progress\n        const aipRef = ref(false);\n        // animation flattened nodes\n        const afNodesRef = ref([]);\n        // Note: Since the virtual list depends on min height, if there's a node\n        // whose height starts from 0, the virtual list will have a wrong height\n        // during animation. This will seldom cause wired scrollbar status. It is\n        // fixable and need some changes in vueuc, I've no time so I just leave it\n        // here. Maybe the bug won't be fixed during the life time of the project.\n        watch(expandedNonLoadingKeysRef, (value, prevValue) => {\n            if (!props.animated || expandAnimationDisabled) {\n                void nextTick(syncScrollbar);\n                return;\n            }\n            const nodeHeight = depx(themeRef.value.self.nodeHeight);\n            const prevVSet = new Set(prevValue);\n            let addedKey = null;\n            let removedKey = null;\n            for (const expandedKey of value) {\n                if (!prevVSet.has(expandedKey)) {\n                    if (addedKey !== null)\n                        return; // multi expand, not triggered by click\n                    addedKey = expandedKey;\n                }\n            }\n            const currentVSet = new Set(value);\n            for (const expandedKey of prevValue) {\n                if (!currentVSet.has(expandedKey)) {\n                    if (removedKey !== null)\n                        return; // multi collapse, not triggered by click\n                    removedKey = expandedKey;\n                }\n            }\n            if (addedKey === null && removedKey === null) {\n                // 1. multi action, not triggered by click\n                // 2. no action, don't know what happened\n                return;\n            }\n            const { virtualScroll } = props;\n            const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;\n            const viewportItemCount = Math.ceil(viewportHeight / nodeHeight) + 1;\n            // play add animation\n            let baseExpandedKeys;\n            if (addedKey !== null) {\n                baseExpandedKeys = prevValue;\n            }\n            if (removedKey !== null) {\n                if (baseExpandedKeys === undefined) {\n                    baseExpandedKeys = value;\n                }\n                else {\n                    baseExpandedKeys = baseExpandedKeys.filter((key) => key !== removedKey);\n                }\n            }\n            aipRef.value = true;\n            afNodesRef.value =\n                displayTreeMateRef.value.getFlattenedNodes(baseExpandedKeys);\n            if (addedKey !== null) {\n                const expandedNodeIndex = afNodesRef.value.findIndex((node) => node.key === addedKey);\n                if (~expandedNodeIndex) {\n                    const children = // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                     afNodesRef.value[expandedNodeIndex].children;\n                    // sometimes user will pass leaf keys in\n                    if (children) {\n                        const expandedChildren = flatten(children, value);\n                        afNodesRef.value.splice(expandedNodeIndex + 1, 0, {\n                            __motion: true,\n                            mode: 'expand',\n                            height: virtualScroll\n                                ? expandedChildren.length * nodeHeight\n                                : undefined,\n                            nodes: virtualScroll\n                                ? expandedChildren.slice(0, viewportItemCount)\n                                : expandedChildren\n                        });\n                    }\n                }\n            }\n            if (removedKey !== null) {\n                const collapsedNodeIndex = afNodesRef.value.findIndex((node) => node.key === removedKey);\n                if (~collapsedNodeIndex) {\n                    const collapsedNodeChildren = afNodesRef.value[collapsedNodeIndex].children;\n                    // Sometime the whole tree is change, remove a key doesn't mean it is collapsed,\n                    // but maybe children removed\n                    if (!collapsedNodeChildren)\n                        return;\n                    // play remove animation\n                    aipRef.value = true;\n                    const collapsedChildren = flatten(collapsedNodeChildren, value);\n                    afNodesRef.value.splice(collapsedNodeIndex + 1, 0, {\n                        __motion: true,\n                        mode: 'collapse',\n                        height: virtualScroll\n                            ? collapsedChildren.length * nodeHeight\n                            : undefined,\n                        nodes: virtualScroll\n                            ? collapsedChildren.slice(0, viewportItemCount)\n                            : collapsedChildren\n                    });\n                }\n            }\n        });\n        const getFIndexRef = computed(() => {\n            return createIndexGetter(fNodesRef.value);\n        });\n        const mergedFNodesRef = computed(() => {\n            if (aipRef.value)\n                return afNodesRef.value;\n            else\n                return fNodesRef.value;\n        });\n        function syncScrollbar() {\n            const { value: scrollbarInst } = scrollbarInstRef;\n            if (scrollbarInst)\n                scrollbarInst.sync();\n        }\n        function handleAfterEnter() {\n            aipRef.value = false;\n            if (props.virtualScroll) {\n                // If virtual scroll, we won't listen to resize during animation, so\n                // resize callback of virtual list won't be called and as a result\n                // scrollbar won't sync. We need to sync scrollbar manually.\n                void nextTick(syncScrollbar);\n            }\n        }\n        function getOptionsByKeys(keys) {\n            const { getNode } = dataTreeMateRef.value;\n            return keys.map((key) => { var _a; return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null; });\n        }\n        function doUpdateExpandedKeys(value, option, meta) {\n            const { 'onUpdate:expandedKeys': _onUpdateExpandedKeys, onUpdateExpandedKeys } = props;\n            uncontrolledExpandedKeysRef.value = value;\n            if (_onUpdateExpandedKeys) {\n                call(_onUpdateExpandedKeys, value, option, meta);\n            }\n            if (onUpdateExpandedKeys) {\n                call(onUpdateExpandedKeys, value, option, meta);\n            }\n        }\n        function doUpdateCheckedKeys(value, option, meta) {\n            const { 'onUpdate:checkedKeys': _onUpdateCheckedKeys, onUpdateCheckedKeys } = props;\n            uncontrolledCheckedKeysRef.value = value;\n            if (onUpdateCheckedKeys) {\n                call(onUpdateCheckedKeys, value, option, meta);\n            }\n            if (_onUpdateCheckedKeys) {\n                call(_onUpdateCheckedKeys, value, option, meta);\n            }\n        }\n        function doUpdateIndeterminateKeys(value, option) {\n            const { 'onUpdate:indeterminateKeys': _onUpdateIndeterminateKeys, onUpdateIndeterminateKeys } = props;\n            if (_onUpdateIndeterminateKeys) {\n                call(_onUpdateIndeterminateKeys, value, option);\n            }\n            if (onUpdateIndeterminateKeys) {\n                call(onUpdateIndeterminateKeys, value, option);\n            }\n        }\n        function doUpdateSelectedKeys(value, option, meta) {\n            const { 'onUpdate:selectedKeys': _onUpdateSelectedKeys, onUpdateSelectedKeys } = props;\n            uncontrolledSelectedKeysRef.value = value;\n            if (onUpdateSelectedKeys) {\n                call(onUpdateSelectedKeys, value, option, meta);\n            }\n            if (_onUpdateSelectedKeys) {\n                call(_onUpdateSelectedKeys, value, option, meta);\n            }\n        }\n        // Drag & Drop\n        function doDragEnter(info) {\n            const { onDragenter } = props;\n            if (onDragenter)\n                call(onDragenter, info);\n        }\n        function doDragLeave(info) {\n            const { onDragleave } = props;\n            if (onDragleave)\n                call(onDragleave, info);\n        }\n        function doDragEnd(info) {\n            const { onDragend } = props;\n            if (onDragend)\n                call(onDragend, info);\n        }\n        function doDragStart(info) {\n            const { onDragstart } = props;\n            if (onDragstart)\n                call(onDragstart, info);\n        }\n        function doDragOver(info) {\n            const { onDragover } = props;\n            if (onDragover)\n                call(onDragover, info);\n        }\n        function doDrop(info) {\n            const { onDrop } = props;\n            if (onDrop)\n                call(onDrop, info);\n        }\n        function resetDndState() {\n            resetDragState();\n            resetDropState();\n        }\n        function resetDragState() {\n            draggingNodeRef.value = null;\n        }\n        function resetDropState() {\n            droppingOffsetLevelRef.value = 0;\n            droppingNodeRef.value = null;\n            droppingMouseNodeRef.value = null;\n            droppingPositionRef.value = null;\n            resetDragExpandState();\n        }\n        function resetDragExpandState() {\n            if (expandTimerId) {\n                window.clearTimeout(expandTimerId);\n                expandTimerId = null;\n            }\n            nodeKeyToBeExpanded = null;\n        }\n        function handleCheck(node, checked) {\n            // We don't guard for leaf only since we have done it in view layer\n            if (props.disabled || isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            if (props.internalUnifySelectCheck && !props.multiple) {\n                handleSelect(node);\n                return;\n            }\n            const checkedAction = checked ? 'check' : 'uncheck';\n            const { checkedKeys, indeterminateKeys } = dataTreeMateRef.value[checkedAction](node.key, displayedCheckedKeysRef.value, {\n                cascade: props.cascade,\n                checkStrategy: mergedCheckStrategyRef.value,\n                allowNotLoaded: props.allowCheckingNotLoaded\n            });\n            doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys), {\n                node: node.rawNode,\n                action: checkedAction\n            });\n            doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));\n        }\n        function toggleExpand(node) {\n            if (props.disabled)\n                return;\n            const { key } = node;\n            const { value: mergedExpandedKeys } = mergedExpandedKeysRef;\n            const index = mergedExpandedKeys.findIndex((expandNodeId) => expandNodeId === key);\n            if (~index) {\n                const expandedKeysAfterChange = Array.from(mergedExpandedKeys);\n                expandedKeysAfterChange.splice(index, 1);\n                doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), {\n                    node: node.rawNode,\n                    action: 'collapse'\n                });\n            }\n            else {\n                const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);\n                if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {\n                    return;\n                }\n                let nextKeys;\n                if (props.accordion) {\n                    const siblingKeySet = new Set(node.siblings.map(({ key }) => key));\n                    nextKeys = mergedExpandedKeys.filter((expandedKey) => {\n                        return !siblingKeySet.has(expandedKey);\n                    });\n                    nextKeys.push(key);\n                }\n                else {\n                    nextKeys = mergedExpandedKeys.concat(key);\n                }\n                doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {\n                    node: node.rawNode,\n                    action: 'expand'\n                });\n            }\n        }\n        function handleSwitcherClick(node) {\n            if (props.disabled || aipRef.value)\n                return;\n            toggleExpand(node);\n        }\n        function handleSelect(node) {\n            if (props.disabled || !props.selectable) {\n                return;\n            }\n            pendingNodeKeyRef.value = node.key;\n            if (props.internalUnifySelectCheck) {\n                const { value: { checkedKeys, indeterminateKeys } } = checkedStatusRef;\n                if (props.multiple) {\n                    handleCheck(node, !(checkedKeys.includes(node.key) ||\n                        indeterminateKeys.includes(node.key)));\n                }\n                else {\n                    doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]), {\n                        node: node.rawNode,\n                        action: 'check'\n                    });\n                }\n            }\n            if (props.multiple) {\n                const selectedKeys = Array.from(mergedSelectedKeysRef.value);\n                const index = selectedKeys.findIndex((key) => key === node.key);\n                if (~index) {\n                    if (props.cancelable) {\n                        selectedKeys.splice(index, 1);\n                    }\n                }\n                else if (!~index) {\n                    selectedKeys.push(node.key);\n                }\n                doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys), {\n                    node: node.rawNode,\n                    action: ~index ? 'unselect' : 'select'\n                });\n            }\n            else {\n                const selectedKeys = mergedSelectedKeysRef.value;\n                if (selectedKeys.includes(node.key)) {\n                    if (props.cancelable) {\n                        doUpdateSelectedKeys([], [], {\n                            node: node.rawNode,\n                            action: 'unselect'\n                        });\n                    }\n                }\n                else {\n                    doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]), {\n                        node: node.rawNode,\n                        action: 'select'\n                    });\n                }\n            }\n        }\n        function expandDragEnterNode(node) {\n            if (expandTimerId) {\n                window.clearTimeout(expandTimerId);\n                expandTimerId = null;\n            }\n            // Don't expand leaf node.\n            if (node.isLeaf)\n                return;\n            nodeKeyToBeExpanded = node.key;\n            const expand = () => {\n                if (nodeKeyToBeExpanded !== node.key)\n                    return;\n                const { value: droppingMouseNode } = droppingMouseNodeRef;\n                if (droppingMouseNode &&\n                    droppingMouseNode.key === node.key &&\n                    !mergedExpandedKeysRef.value.includes(node.key)) {\n                    const nextKeys = mergedExpandedKeysRef.value.concat(node.key);\n                    doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {\n                        node: node.rawNode,\n                        action: 'expand'\n                    });\n                }\n                expandTimerId = null;\n                nodeKeyToBeExpanded = null;\n            };\n            if (!node.shallowLoaded) {\n                expandTimerId = window.setTimeout(() => {\n                    void triggerLoading(node).then(() => {\n                        expand();\n                    });\n                }, 1000);\n            }\n            else {\n                expandTimerId = window.setTimeout(() => {\n                    expand();\n                }, 1000);\n            }\n        }\n        // Dnd\n        function handleDragEnter({ event, node }) {\n            // node should be a tmNode\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            handleDragOver({ event, node }, false);\n            doDragEnter({ event, node: node.rawNode });\n        }\n        function handleDragLeave({ event, node }) {\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            doDragLeave({ event, node: node.rawNode });\n        }\n        function handleDragLeaveTree(e) {\n            if (e.target !== e.currentTarget)\n                return;\n            resetDropState();\n        }\n        // Dragend is ok, we don't need to add global listener to reset drag status\n        function handleDragEnd({ event, node }) {\n            resetDndState();\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            doDragEnd({ event, node: node.rawNode });\n        }\n        function handleDragStart({ event, node }) {\n            var _a;\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            // Most of time, the image will block user's view\n            emptyImage && ((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.setDragImage(emptyImage, 0, 0));\n            dragStartX = event.clientX;\n            draggingNodeRef.value = node;\n            doDragStart({ event, node: node.rawNode });\n        }\n        function handleDragOver({ event, node }, emit = true) {\n            var _a;\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            const { value: draggingNode } = draggingNodeRef;\n            if (!draggingNode)\n                return;\n            const { allowDrop, indent } = props;\n            if (emit)\n                doDragOver({ event, node: node.rawNode });\n            // Update dropping node\n            const el = event.currentTarget;\n            const { height: elOffsetHeight, top: elClientTop } = el.getBoundingClientRect();\n            const eventOffsetY = event.clientY - elClientTop;\n            let mousePosition;\n            const allowDropInside = allowDrop({\n                node: node.rawNode,\n                dropPosition: 'inside',\n                phase: 'drag'\n            });\n            if (allowDropInside) {\n                if (eventOffsetY <= 8) {\n                    mousePosition = 'before';\n                }\n                else if (eventOffsetY >= elOffsetHeight - 8) {\n                    mousePosition = 'after';\n                }\n                else {\n                    mousePosition = 'inside';\n                }\n            }\n            else {\n                if (eventOffsetY <= elOffsetHeight / 2) {\n                    mousePosition = 'before';\n                }\n                else {\n                    mousePosition = 'after';\n                }\n            }\n            const { value: getFindex } = getFIndexRef;\n            /** determine the drop position and drop node */\n            /** the dropping node needn't to be the mouse hovering node! */\n            /**\n             * if there is something i've learned from implementing a complex\n             * drag & drop. that is never write unit test before you really figure\n             * out what behavior is exactly you want.\n             */\n            let finalDropNode;\n            let finalDropPosition;\n            const hoverNodeFIndex = getFindex(node.key);\n            if (hoverNodeFIndex === null) {\n                resetDropState();\n                return;\n            }\n            let mouseAtExpandedNonLeafNode = false;\n            if (mousePosition === 'inside') {\n                finalDropNode = node;\n                finalDropPosition = 'inside';\n            }\n            else {\n                if (mousePosition === 'before') {\n                    if (node.isFirstChild) {\n                        finalDropNode = node;\n                        finalDropPosition = 'before';\n                    }\n                    else {\n                        finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];\n                        finalDropPosition = 'after';\n                    }\n                }\n                else {\n                    finalDropNode = node;\n                    finalDropPosition = 'after';\n                }\n            }\n            // If the node is non-leaf and it is expanded, we don't allow it to\n            // drop after it and change it to drop before its next view sibling\n            if (!finalDropNode.isLeaf &&\n                mergedExpandedKeysRef.value.includes(finalDropNode.key)) {\n                mouseAtExpandedNonLeafNode = true;\n                if (finalDropPosition === 'after') {\n                    finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];\n                    if (!finalDropNode) {\n                        // maybe there is no next view sibling when non-leaf node has no\n                        // children and it is the last node in the tree\n                        finalDropNode = node;\n                        finalDropPosition = 'inside';\n                    }\n                    else {\n                        finalDropPosition = 'before';\n                    }\n                }\n            }\n            const droppingMouseNode = finalDropNode;\n            droppingMouseNodeRef.value = droppingMouseNode;\n            // This is a speacial case, user is dragging a last child itself, so we\n            // only view it as they are trying to drop after it.\n            // There are some relevant codes in bailout 1's child branch.\n            // Also, the expand bailout should have a high priority. If it's non-leaf\n            // node and expanded, keep its origin drop position\n            if (!mouseAtExpandedNonLeafNode &&\n                draggingNode.isLastChild &&\n                draggingNode.key === finalDropNode.key) {\n                finalDropPosition = 'after';\n            }\n            if (finalDropPosition === 'after') {\n                let offset = dragStartX - event.clientX; // drag left => > 0\n                let offsetLevel = 0;\n                while (offset >= indent / 2 && // divide by 2 to make it easier to trigger\n                    finalDropNode.parent !== null &&\n                    finalDropNode.isLastChild &&\n                    offsetLevel < 1) {\n                    offset -= indent;\n                    offsetLevel += 1;\n                    finalDropNode = finalDropNode.parent;\n                }\n                droppingOffsetLevelRef.value = offsetLevel;\n            }\n            else {\n                droppingOffsetLevelRef.value = 0;\n            }\n            // Bailout 1\n            // Drag self into self\n            // Drag it into direct parent\n            if (draggingNode.contains(finalDropNode) ||\n                (finalDropPosition === 'inside' &&\n                    ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key)) {\n                if (draggingNode.key === droppingMouseNode.key &&\n                    draggingNode.key === finalDropNode.key) {\n                    // This is special case that we want ui to show a mark to guide user\n                    // to start dragging. Nor they will think nothing happens.\n                    // However this is an invalid drop, we need to guard it inside\n                    // handleDrop\n                }\n                else {\n                    resetDropState();\n                    return;\n                }\n            }\n            // Bailout 3\n            if (!allowDrop({\n                node: finalDropNode.rawNode,\n                dropPosition: finalDropPosition,\n                phase: 'drag'\n            })) {\n                resetDropState();\n                return;\n            }\n            if (draggingNode.key === finalDropNode.key) {\n                // don't expand when drag on itself\n                resetDragExpandState();\n            }\n            else {\n                if (nodeKeyToBeExpanded !== finalDropNode.key) {\n                    if (finalDropPosition === 'inside') {\n                        if (props.expandOnDragenter) {\n                            expandDragEnterNode(finalDropNode);\n                            // Bailout 4\n                            // not try to loading\n                            if (!finalDropNode.shallowLoaded &&\n                                nodeKeyToBeExpanded !== finalDropNode.key) {\n                                resetDndState();\n                                return;\n                            }\n                        }\n                        else {\n                            // Bailout 5\n                            // never expands on drag\n                            if (!finalDropNode.shallowLoaded) {\n                                resetDndState();\n                                return;\n                            }\n                        }\n                    }\n                    else {\n                        resetDragExpandState();\n                    }\n                }\n                else {\n                    if (finalDropPosition !== 'inside') {\n                        resetDragExpandState();\n                    }\n                }\n            }\n            droppingPositionRef.value = finalDropPosition;\n            droppingNodeRef.value = finalDropNode;\n        }\n        function handleDrop({ event, node, dropPosition }) {\n            if (!props.draggable ||\n                props.disabled ||\n                isNodeDisabled(node, props.disabledField)) {\n                return;\n            }\n            const { value: draggingNode } = draggingNodeRef;\n            const { value: droppingNode } = droppingNodeRef;\n            const { value: droppingPosition } = droppingPositionRef;\n            if (!draggingNode || !droppingNode || !droppingPosition) {\n                return;\n            }\n            // Bailout 1\n            if (!props.allowDrop({\n                node: droppingNode.rawNode,\n                dropPosition: droppingPosition,\n                phase: 'drag'\n            })) {\n                return;\n            }\n            // Bailout 2\n            // This is a special case to guard since we want ui to show the status\n            // but not to emit a event\n            if (draggingNode.key === droppingNode.key) {\n                return;\n            }\n            // Bailout 3\n            // insert before its next node\n            // insert after its prev node\n            if (droppingPosition === 'before') {\n                const nextNode = draggingNode.getNext({ includeDisabled: true });\n                if (nextNode) {\n                    if (nextNode.key === droppingNode.key) {\n                        resetDropState();\n                        return;\n                    }\n                }\n            }\n            if (droppingPosition === 'after') {\n                const prevNode = draggingNode.getPrev({ includeDisabled: true });\n                if (prevNode) {\n                    if (prevNode.key === droppingNode.key) {\n                        resetDropState();\n                        return;\n                    }\n                }\n            }\n            doDrop({\n                event,\n                node: droppingNode.rawNode,\n                dragNode: draggingNode.rawNode,\n                dropPosition\n            });\n            resetDndState();\n        }\n        function handleScroll() {\n            syncScrollbar();\n        }\n        function handleResize() {\n            syncScrollbar();\n        }\n        function handleFocusout(e) {\n            var _a;\n            if (props.virtualScroll || props.internalScrollable) {\n                const { value: scrollbarInst } = scrollbarInstRef;\n                if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {\n                    return;\n                }\n                pendingNodeKeyRef.value = null;\n            }\n            else {\n                const { value: selfEl } = selfElRef;\n                if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget))\n                    return;\n                pendingNodeKeyRef.value = null;\n            }\n        }\n        watch(pendingNodeKeyRef, (value) => {\n            var _a, _b;\n            if (value === null)\n                return;\n            if (props.virtualScroll) {\n                (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({ key: value });\n            }\n            else if (props.internalScrollable) {\n                const { value: scrollbarInst } = scrollbarInstRef;\n                if (scrollbarInst === null)\n                    return;\n                const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key=\"${createDataKey(value)}\"]`);\n                if (!targetEl)\n                    return;\n                scrollbarInst.scrollTo({\n                    el: targetEl\n                });\n            }\n        });\n        provide(treeInjectionKey, {\n            loadingKeysRef,\n            highlightKeySetRef: mergedHighlightKeySetRef,\n            displayedCheckedKeysRef,\n            displayedIndeterminateKeysRef,\n            mergedSelectedKeysRef,\n            mergedExpandedKeysRef,\n            mergedThemeRef: themeRef,\n            mergedCheckStrategyRef,\n            nodePropsRef: toRef(props, 'nodeProps'),\n            disabledRef: toRef(props, 'disabled'),\n            checkableRef: toRef(props, 'checkable'),\n            selectableRef: toRef(props, 'selectable'),\n            expandOnClickRef: toRef(props, 'expandOnClick'),\n            onLoadRef: toRef(props, 'onLoad'),\n            draggableRef: toRef(props, 'draggable'),\n            blockLineRef: toRef(props, 'blockLine'),\n            indentRef: toRef(props, 'indent'),\n            cascadeRef: toRef(props, 'cascade'),\n            checkOnClickRef: toRef(props, 'checkOnClick'),\n            checkboxPlacementRef: props.checkboxPlacement,\n            droppingMouseNodeRef,\n            droppingNodeParentRef,\n            draggingNodeRef,\n            droppingPositionRef,\n            droppingOffsetLevelRef,\n            fNodesRef,\n            pendingNodeKeyRef,\n            showLineRef: toRef(props, 'showLine'),\n            disabledFieldRef: toRef(props, 'disabledField'),\n            internalScrollableRef: toRef(props, 'internalScrollable'),\n            internalCheckboxFocusableRef: toRef(props, 'internalCheckboxFocusable'),\n            internalTreeSelect: props.internalTreeSelect,\n            renderLabelRef: toRef(props, 'renderLabel'),\n            renderPrefixRef: toRef(props, 'renderPrefix'),\n            renderSuffixRef: toRef(props, 'renderSuffix'),\n            renderSwitcherIconRef: toRef(props, 'renderSwitcherIcon'),\n            labelFieldRef: toRef(props, 'labelField'),\n            multipleRef: toRef(props, 'multiple'),\n            handleSwitcherClick,\n            handleDragEnd,\n            handleDragEnter,\n            handleDragLeave,\n            handleDragStart,\n            handleDrop,\n            handleDragOver,\n            handleSelect,\n            handleCheck\n        });\n        function scrollTo(options) {\n            var _a;\n            (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options);\n        }\n        const exposedMethods = {\n            handleKeydown,\n            scrollTo,\n            getCheckedData: () => {\n                if (!props.checkable)\n                    return { keys: [], options: [] };\n                const { checkedKeys } = checkedStatusRef.value;\n                return {\n                    keys: checkedKeys,\n                    options: getOptionsByKeys(checkedKeys)\n                };\n            },\n            getIndeterminateData: () => {\n                if (!props.checkable)\n                    return { keys: [], options: [] };\n                const { indeterminateKeys } = checkedStatusRef.value;\n                return {\n                    keys: indeterminateKeys,\n                    options: getOptionsByKeys(indeterminateKeys)\n                };\n            }\n        };\n        const cssVarsRef = computed(() => {\n            const { common: { cubicBezierEaseInOut }, self: { fontSize, nodeBorderRadius, nodeColorHover, nodeColorPressed, nodeColorActive, arrowColor, loadingColor, nodeTextColor, nodeTextColorDisabled, dropMarkColor, nodeWrapperPadding, nodeHeight, lineHeight, lineColor } } = themeRef.value;\n            const lineOffsetTop = getPadding(nodeWrapperPadding, 'top');\n            const lineOffsetBottom = getPadding(nodeWrapperPadding, 'bottom');\n            const nodeContentHeight = pxfy(depx(nodeHeight) - depx(lineOffsetTop) - depx(lineOffsetBottom));\n            return {\n                '--n-arrow-color': arrowColor,\n                '--n-loading-color': loadingColor,\n                '--n-bezier': cubicBezierEaseInOut,\n                '--n-font-size': fontSize,\n                '--n-node-border-radius': nodeBorderRadius,\n                '--n-node-color-active': nodeColorActive,\n                '--n-node-color-hover': nodeColorHover,\n                '--n-node-color-pressed': nodeColorPressed,\n                '--n-node-text-color': nodeTextColor,\n                '--n-node-text-color-disabled': nodeTextColorDisabled,\n                '--n-drop-mark-color': dropMarkColor,\n                '--n-node-wrapper-padding': nodeWrapperPadding,\n                '--n-line-offset-top': `-${lineOffsetTop}`,\n                '--n-line-offset-bottom': `-${lineOffsetBottom}`,\n                '--n-node-content-height': nodeContentHeight,\n                '--n-line-height': lineHeight,\n                '--n-line-color': lineColor\n            };\n        });\n        const themeClassHandle = inlineThemeDisabled\n            ? useThemeClass('tree', undefined, cssVarsRef, props)\n            : undefined;\n        return Object.assign(Object.assign({}, exposedMethods), { mergedClsPrefix: mergedClsPrefixRef, mergedTheme: themeRef, rtlEnabled: rtlEnabledRef, fNodes: mergedFNodesRef, aip: aipRef, selfElRef,\n            virtualListInstRef,\n            scrollbarInstRef,\n            handleFocusout,\n            handleDragLeaveTree,\n            handleScroll,\n            getScrollContainer,\n            getScrollContent,\n            handleAfterEnter,\n            handleResize, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });\n    },\n    render() {\n        var _a;\n        const { fNodes, internalRenderEmpty } = this;\n        if (!fNodes.length && internalRenderEmpty) {\n            return internalRenderEmpty();\n        }\n        const { mergedClsPrefix, blockNode, blockLine, draggable, disabled, internalFocusable, checkable, handleKeydown, rtlEnabled, handleFocusout, scrollbarProps } = this;\n        const mergedFocusable = internalFocusable && !disabled;\n        const tabindex = mergedFocusable ? '0' : undefined;\n        const treeClass = [\n            `${mergedClsPrefix}-tree`,\n            rtlEnabled && `${mergedClsPrefix}-tree--rtl`,\n            checkable && `${mergedClsPrefix}-tree--checkable`,\n            (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`,\n            blockLine && `${mergedClsPrefix}-tree--block-line`\n        ];\n        const createNode = (tmNode) => {\n            return '__motion' in tmNode ? (h(MotionWrapper, { height: tmNode.height, nodes: tmNode.nodes, clsPrefix: mergedClsPrefix, mode: tmNode.mode, onAfterEnter: this.handleAfterEnter })) : (h(NTreeNode, { key: tmNode.key, tmNode: tmNode, clsPrefix: mergedClsPrefix }));\n        };\n        if (this.virtualScroll) {\n            const { mergedTheme, internalScrollablePadding } = this;\n            const padding = getPadding(internalScrollablePadding || '0');\n            return (h(NxScrollbar, Object.assign({}, scrollbarProps, { ref: \"scrollbarInstRef\", onDragleave: draggable ? this.handleDragLeaveTree : undefined, container: this.getScrollContainer, content: this.getScrollContent, class: treeClass, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, tabindex: tabindex, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined }), {\n                default: () => {\n                    var _a;\n                    (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n                    return !fNodes.length ? (resolveSlot(this.$slots.empty, () => [\n                        h(NEmpty, { class: `${mergedClsPrefix}-tree__empty`, theme: this.mergedTheme.peers.Empty, themeOverrides: this.mergedTheme.peerOverrides.Empty })\n                    ])) : (h(VVirtualList, { ref: \"virtualListInstRef\", items: this.fNodes, itemSize: depx(mergedTheme.self.nodeHeight), ignoreItemResize: this.aip, paddingTop: padding.top, paddingBottom: padding.bottom, class: this.themeClass, style: [\n                            this.cssVars,\n                            {\n                                paddingLeft: padding.left,\n                                paddingRight: padding.right\n                            }\n                        ], onScroll: this.handleScroll, onResize: this.handleResize, showScrollbar: false, itemResizable: true }, {\n                        default: ({ item }) => createNode(item)\n                    }));\n                }\n            }));\n        }\n        const { internalScrollable } = this;\n        treeClass.push(this.themeClass);\n        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);\n        if (internalScrollable) {\n            return (h(NxScrollbar, Object.assign({}, scrollbarProps, { class: treeClass, tabindex: tabindex, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined, style: this.cssVars, contentStyle: { padding: this.internalScrollablePadding } }), {\n                default: () => (h(\"div\", { onDragleave: draggable ? this.handleDragLeaveTree : undefined, ref: \"selfElRef\" }, this.fNodes.map(createNode)))\n            }));\n        }\n        else {\n            return (h(\"div\", { class: treeClass, tabindex: tabindex, ref: \"selfElRef\", style: this.cssVars, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined, onDragleave: draggable ? this.handleDragLeaveTree : undefined }, !fNodes.length\n                ? resolveSlot(this.$slots.empty, () => [\n                    h(NEmpty, { class: `${mergedClsPrefix}-tree__empty`, theme: this.mergedTheme.peers.Empty, themeOverrides: this.mergedTheme.peerOverrides.Empty })\n                ])\n                : fNodes.map(createNode)));\n        }\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
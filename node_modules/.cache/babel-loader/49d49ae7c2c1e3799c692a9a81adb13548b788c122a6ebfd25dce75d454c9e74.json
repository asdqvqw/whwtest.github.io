{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { computed } from 'vue';\nimport { isBrowser } from '../../_utils';\nimport { happensIn } from 'seemly';\nexport function useMergedCheckStrategy(props) {\n  return computed(() => props.leafOnly ? 'child' : props.checkStrategy);\n}\nexport function isNodeDisabled(node, disabledField) {\n  return !!node.rawNode[disabledField];\n}\nfunction traverse(nodes, childrenField, callback, callbackAfter) {\n  nodes === null || nodes === void 0 ? void 0 : nodes.forEach(node => {\n    callback(node);\n    traverse(node[childrenField], childrenField, callback, callbackAfter);\n    callbackAfter(node);\n  });\n}\nexport function keysWithFilter(nodes, pattern, keyField, childrenField, filter) {\n  const keys = new Set();\n  const highlightKeySet = new Set();\n  const path = [];\n  traverse(nodes, childrenField, node => {\n    path.push(node);\n    if (filter(pattern, node)) {\n      highlightKeySet.add(node[keyField]);\n      for (let i = path.length - 2; i >= 0; --i) {\n        if (!keys.has(path[i][keyField])) {\n          keys.add(path[i][keyField]);\n        } else {\n          return;\n        }\n      }\n    }\n  }, () => {\n    path.pop();\n  });\n  return {\n    expandedKeys: Array.from(keys),\n    highlightKeySet\n  };\n}\nconst emptyImage = null;\nif (isBrowser && Image) {\n  const emptyImage = new Image();\n  emptyImage.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n}\nexport { emptyImage };\nexport function filterTree(tree, filter, pattern, keyField, childrenField) {\n  const visitedTailKeys = new Set();\n  const visitedNonTailKeys = new Set();\n  const highlightKeySet = new Set();\n  const expandedKeys = [];\n  const filteredTree = [];\n  const path = [];\n  function visit(t) {\n    t.forEach(n => {\n      path.push(n);\n      if (filter(pattern, n)) {\n        visitedTailKeys.add(n[keyField]);\n        highlightKeySet.add(n[keyField]);\n        for (let i = path.length - 2; i >= 0; --i) {\n          const key = path[i][keyField];\n          if (!visitedNonTailKeys.has(key)) {\n            visitedNonTailKeys.add(key);\n            if (visitedTailKeys.has(key)) {\n              visitedTailKeys.delete(key);\n            }\n          } else {\n            break;\n          }\n        }\n      }\n      const children = n[childrenField];\n      if (children) {\n        visit(children);\n      }\n      path.pop();\n    });\n  }\n  visit(tree);\n  function build(t, sibs) {\n    t.forEach(n => {\n      const key = n[keyField];\n      const isVisitedTail = visitedTailKeys.has(key);\n      const isVisitedNonTail = visitedNonTailKeys.has(key);\n      if (!isVisitedTail && !isVisitedNonTail) return;\n      const children = n[childrenField];\n      if (children) {\n        if (isVisitedTail) {\n          // If it is visited path tail, use origin node\n          sibs.push(n);\n        } else {\n          // It it is not visited path tail, use cloned node\n          expandedKeys.push(key);\n          const clonedNode = Object.assign(Object.assign({}, n), {\n            [childrenField]: []\n          });\n          sibs.push(clonedNode);\n          build(children, clonedNode[childrenField]);\n        }\n      } else {\n        sibs.push(n);\n      }\n    });\n  }\n  build(tree, filteredTree);\n  return {\n    filteredTree,\n    highlightKeySet,\n    expandedKeys\n  };\n}\nexport function treeGetClickTarget(e) {\n  if (happensIn(e, 'checkbox')) {\n    return 'checkbox';\n  } else if (happensIn(e, 'switcher')) {\n    return 'switcher';\n  } else {\n    return 'node';\n  }\n}","map":{"version":3,"names":["computed","isBrowser","happensIn","useMergedCheckStrategy","props","leafOnly","checkStrategy","isNodeDisabled","node","disabledField","rawNode","traverse","nodes","childrenField","callback","callbackAfter","forEach","keysWithFilter","pattern","keyField","filter","keys","Set","highlightKeySet","path","push","add","i","length","has","pop","expandedKeys","Array","from","emptyImage","Image","src","filterTree","tree","visitedTailKeys","visitedNonTailKeys","filteredTree","visit","t","n","key","delete","children","build","sibs","isVisitedTail","isVisitedNonTail","clonedNode","Object","assign","treeGetClickTarget","e"],"sources":["/home/whw/Vue/whwtest.github.io/node_modules/naive-ui/es/tree/src/utils.js"],"sourcesContent":["import { computed } from 'vue';\nimport { isBrowser } from '../../_utils';\nimport { happensIn } from 'seemly';\nexport function useMergedCheckStrategy(props) {\n    return computed(() => (props.leafOnly ? 'child' : props.checkStrategy));\n}\nexport function isNodeDisabled(node, disabledField) {\n    return !!node.rawNode[disabledField];\n}\nfunction traverse(nodes, childrenField, callback, callbackAfter) {\n    nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {\n        callback(node);\n        traverse(node[childrenField], childrenField, callback, callbackAfter);\n        callbackAfter(node);\n    });\n}\nexport function keysWithFilter(nodes, pattern, keyField, childrenField, filter) {\n    const keys = new Set();\n    const highlightKeySet = new Set();\n    const path = [];\n    traverse(nodes, childrenField, (node) => {\n        path.push(node);\n        if (filter(pattern, node)) {\n            highlightKeySet.add(node[keyField]);\n            for (let i = path.length - 2; i >= 0; --i) {\n                if (!keys.has(path[i][keyField])) {\n                    keys.add(path[i][keyField]);\n                }\n                else {\n                    return;\n                }\n            }\n        }\n    }, () => {\n        path.pop();\n    });\n    return {\n        expandedKeys: Array.from(keys),\n        highlightKeySet\n    };\n}\nconst emptyImage = null;\nif (isBrowser && Image) {\n    const emptyImage = new Image();\n    emptyImage.src =\n        'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n}\nexport { emptyImage };\nexport function filterTree(tree, filter, pattern, keyField, childrenField) {\n    const visitedTailKeys = new Set();\n    const visitedNonTailKeys = new Set();\n    const highlightKeySet = new Set();\n    const expandedKeys = [];\n    const filteredTree = [];\n    const path = [];\n    function visit(t) {\n        t.forEach((n) => {\n            path.push(n);\n            if (filter(pattern, n)) {\n                visitedTailKeys.add(n[keyField]);\n                highlightKeySet.add(n[keyField]);\n                for (let i = path.length - 2; i >= 0; --i) {\n                    const key = path[i][keyField];\n                    if (!visitedNonTailKeys.has(key)) {\n                        visitedNonTailKeys.add(key);\n                        if (visitedTailKeys.has(key)) {\n                            visitedTailKeys.delete(key);\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            const children = n[childrenField];\n            if (children) {\n                visit(children);\n            }\n            path.pop();\n        });\n    }\n    visit(tree);\n    function build(t, sibs) {\n        t.forEach((n) => {\n            const key = n[keyField];\n            const isVisitedTail = visitedTailKeys.has(key);\n            const isVisitedNonTail = visitedNonTailKeys.has(key);\n            if (!isVisitedTail && !isVisitedNonTail)\n                return;\n            const children = n[childrenField];\n            if (children) {\n                if (isVisitedTail) {\n                    // If it is visited path tail, use origin node\n                    sibs.push(n);\n                }\n                else {\n                    // It it is not visited path tail, use cloned node\n                    expandedKeys.push(key);\n                    const clonedNode = Object.assign(Object.assign({}, n), { [childrenField]: [] });\n                    sibs.push(clonedNode);\n                    build(children, clonedNode[childrenField]);\n                }\n            }\n            else {\n                sibs.push(n);\n            }\n        });\n    }\n    build(tree, filteredTree);\n    return {\n        filteredTree,\n        highlightKeySet,\n        expandedKeys\n    };\n}\nexport function treeGetClickTarget(e) {\n    if (happensIn(e, 'checkbox')) {\n        return 'checkbox';\n    }\n    else if (happensIn(e, 'switcher')) {\n        return 'switcher';\n    }\n    else {\n        return 'node';\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { defineComponent, h, computed } from 'vue';\nimport { hsv2rgb, hsva, toRgbaString } from 'seemly';\nimport { convertColor, getModeFromValue } from './utils';\nimport { warn } from '../../_utils';\n// Try to normalize the color values to ensure that they are valid CSS colors\nfunction normalizeColor(color, mode) {\n  if (mode === 'hsv') {\n    const [h, s, v, a] = hsva(color);\n    return toRgbaString([...hsv2rgb(h, s, v), a]);\n  }\n  // For the mode that is not in preset, we keep the original value.\n  // For color names, they are legal to CSS, so we don’t deal with them,\n  // and only standardize them when outputting.\n  return color;\n}\nfunction getHexFromName(color) {\n  const ctx = document.createElement('canvas').getContext('2d');\n  if (!ctx) {\n    return '#000000';\n  }\n  ctx.fillStyle = color;\n  return ctx.fillStyle;\n}\nexport default defineComponent({\n  name: 'ColorPickerSwatches',\n  props: {\n    clsPrefix: {\n      type: String,\n      required: true\n    },\n    mode: {\n      type: String,\n      required: true\n    },\n    swatches: {\n      type: Array,\n      required: true\n    },\n    onUpdateColor: {\n      type: Function,\n      required: true\n    }\n  },\n  setup(props) {\n    const parsedSwatchesRef = computed(() => props.swatches.map(value => {\n      const mode = getModeFromValue(value);\n      return {\n        value,\n        mode,\n        legalValue: normalizeColor(value, mode)\n      };\n    }));\n    function normalizeOutput(parsed) {\n      const {\n        mode: modeProp\n      } = props;\n      let {\n        value,\n        mode: swatchColorMode\n      } = parsed;\n      // color name is converted to hex\n      if (!swatchColorMode) {\n        swatchColorMode = 'hex';\n        if (/^[a-zA-Z]+$/.test(value)) {\n          value = getHexFromName(value);\n        } else {\n          // for invalid color, we make it black\n          warn('color-picker', `color ${value} in swatches is invalid.`);\n          value = '#000000';\n        }\n      }\n      if (swatchColorMode === modeProp) return value;\n      // swatch value to current mode value\n      return convertColor(value, modeProp, swatchColorMode);\n    }\n    function handleSwatchSelect(parsed) {\n      props.onUpdateColor(normalizeOutput(parsed));\n    }\n    function handleSwatchKeyDown(e, parsed) {\n      if (e.key === 'Enter') handleSwatchSelect(parsed);\n    }\n    return {\n      parsedSwatchesRef,\n      handleSwatchSelect,\n      handleSwatchKeyDown\n    };\n  },\n  render() {\n    const {\n      clsPrefix\n    } = this;\n    return h(\"div\", {\n      class: `${clsPrefix}-color-picker-swatches`\n    }, this.parsedSwatchesRef.map(swatch => h(\"div\", {\n      class: `${clsPrefix}-color-picker-swatch`,\n      tabindex: 0,\n      onClick: () => {\n        this.handleSwatchSelect(swatch);\n      },\n      onKeydown: e => {\n        this.handleSwatchKeyDown(e, swatch);\n      }\n    }, h(\"div\", {\n      class: `${clsPrefix}-color-picker-swatch__fill`,\n      style: {\n        background: swatch.legalValue\n      }\n    }))));\n  }\n});","map":{"version":3,"names":["defineComponent","h","computed","hsv2rgb","hsva","toRgbaString","convertColor","getModeFromValue","warn","normalizeColor","color","mode","s","v","a","getHexFromName","ctx","document","createElement","getContext","fillStyle","name","props","clsPrefix","type","String","required","swatches","Array","onUpdateColor","Function","setup","parsedSwatchesRef","map","value","legalValue","normalizeOutput","parsed","modeProp","swatchColorMode","test","handleSwatchSelect","handleSwatchKeyDown","e","key","render","class","swatch","tabindex","onClick","onKeydown","style","background"],"sources":["/home/whw/Vue/whwtest.github.io/node_modules/naive-ui/es/color-picker/src/ColorPickerSwatches.js"],"sourcesContent":["import { defineComponent, h, computed } from 'vue';\nimport { hsv2rgb, hsva, toRgbaString } from 'seemly';\nimport { convertColor, getModeFromValue } from './utils';\nimport { warn } from '../../_utils';\n// Try to normalize the color values to ensure that they are valid CSS colors\nfunction normalizeColor(color, mode) {\n    if (mode === 'hsv') {\n        const [h, s, v, a] = hsva(color);\n        return toRgbaString([...hsv2rgb(h, s, v), a]);\n    }\n    // For the mode that is not in preset, we keep the original value.\n    // For color names, they are legal to CSS, so we don’t deal with them,\n    // and only standardize them when outputting.\n    return color;\n}\nfunction getHexFromName(color) {\n    const ctx = document.createElement('canvas').getContext('2d');\n    if (!ctx) {\n        return '#000000';\n    }\n    ctx.fillStyle = color;\n    return ctx.fillStyle;\n}\nexport default defineComponent({\n    name: 'ColorPickerSwatches',\n    props: {\n        clsPrefix: {\n            type: String,\n            required: true\n        },\n        mode: {\n            type: String,\n            required: true\n        },\n        swatches: {\n            type: Array,\n            required: true\n        },\n        onUpdateColor: {\n            type: Function,\n            required: true\n        }\n    },\n    setup(props) {\n        const parsedSwatchesRef = computed(() => props.swatches.map((value) => {\n            const mode = getModeFromValue(value);\n            return {\n                value,\n                mode,\n                legalValue: normalizeColor(value, mode)\n            };\n        }));\n        function normalizeOutput(parsed) {\n            const { mode: modeProp } = props;\n            let { value, mode: swatchColorMode } = parsed;\n            // color name is converted to hex\n            if (!swatchColorMode) {\n                swatchColorMode = 'hex';\n                if (/^[a-zA-Z]+$/.test(value)) {\n                    value = getHexFromName(value);\n                }\n                else {\n                    // for invalid color, we make it black\n                    warn('color-picker', `color ${value} in swatches is invalid.`);\n                    value = '#000000';\n                }\n            }\n            if (swatchColorMode === modeProp)\n                return value;\n            // swatch value to current mode value\n            return convertColor(value, modeProp, swatchColorMode);\n        }\n        function handleSwatchSelect(parsed) {\n            props.onUpdateColor(normalizeOutput(parsed));\n        }\n        function handleSwatchKeyDown(e, parsed) {\n            if (e.key === 'Enter')\n                handleSwatchSelect(parsed);\n        }\n        return {\n            parsedSwatchesRef,\n            handleSwatchSelect,\n            handleSwatchKeyDown\n        };\n    },\n    render() {\n        const { clsPrefix } = this;\n        return (h(\"div\", { class: `${clsPrefix}-color-picker-swatches` }, this.parsedSwatchesRef.map((swatch) => (h(\"div\", { class: `${clsPrefix}-color-picker-swatch`, tabindex: 0, onClick: () => {\n                this.handleSwatchSelect(swatch);\n            }, onKeydown: (e) => {\n                this.handleSwatchKeyDown(e, swatch);\n            } },\n            h(\"div\", { class: `${clsPrefix}-color-picker-swatch__fill`, style: { background: swatch.legalValue } }))))));\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}